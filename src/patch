Only in /X11/blong/httpd/src/: .#cgi.c.1.41
Only in /X11/blong/httpd/src/: .#fcgi.c.1.2
Only in /X11/blong/httpd/src/: .#fcgi.h.1.1
Only in /X11/blong/httpd/src/: .#http_auth.c.1.80
Only in /X11/blong/httpd/src/: .#http_auth.h.1.24
Only in /X11/blong/httpd/src/: .#http_send.c.1.30
Only in /X11/blong/httpd/src/: .#http_shttp.h.1.3
Only in /X11/blong/httpd/src/: .pure
Only in /X11/blong/httpd/src/: 112a.ident.patch
Only in /X11/blong/httpd/src/: BUGS
diff -brc ./CHANGES /X11/blong/httpd/src//CHANGES
*** ./CHANGES	Tue Jun 25 17:18:12 1996
--- /X11/blong/httpd/src//CHANGES	Tue May 28 10:44:31 1996
***************
*** 1,13 ****
  
- Fixes for 1.5.2
- ------------------
  *) Changed getline rfc822 line wrap to check for validity of the next bits
     before attempting to see them
  *) Changed imagemap.c so relative URLs actually work
  *) Don't core dump on a method only request
  *) reset errno to 0 in send_fp so we break out of loop
- *) somewhere we stopped killing cgi scripts on SIGALRM and SIGPIPE
- *) changed group handling support to support multiple groups again
- *) reset content_length before scanning cgi headers, not after
- 
- 
--- 1,6 ----
Only in /X11/blong/httpd/src/: CVS
Only in /X11/blong/httpd/src/: DESC
diff -brc ./Makefile /X11/blong/httpd/src//Makefile
*** ./Makefile	Tue Jun 25 17:06:12 1996
--- /X11/blong/httpd/src//Makefile	Wed Jun 12 17:45:00 1996
***************
*** 16,24 ****
  # If you want to ensure that CGI scripts can't mess with the log files,
  # use -DSECURE_LOGS
  
  CFLAGS= -g
  #CFLAGS= -pg -DPROFILE
! #CFLAGS= -g -ansi -pedantic -Wall -DAIX_BROKEN_HEADERS
  
  # FCGI Support
  #
--- 16,26 ----
  # If you want to ensure that CGI scripts can't mess with the log files,
  # use -DSECURE_LOGS
  
+ #CFLAGS= -O2
  CFLAGS= -g
  #CFLAGS= -pg -DPROFILE
! #CFLAGS= -g -ansi -pedantic -Wall #-DAIX_BROKEN_HEADERS
! #CFLAGS= -O2 -fullwarn -wlint,-vui
  
  # FCGI Support
  #
***************
*** 26,32 ****
--- 28,62 ----
  # Currently uses the TCL library for strings, which requires the math library
  
  #FCGI_CFLAGS = -DFCGI_SUPPORT -I/local/include
+ #FCGI_OBJS = fcgi.o
+ #FCGI_LIBS = 
  
+ # SHTTP Support
+ #
+ # To enable SHTTP, choose platform and uncomment the following SHTTP lines
+ 
+ #PLATFORM=solaris24
+ #PLATFORM=sunos413-export
+ #PLATFORM=sunos413
+ #PLATFORM=irix52
+ 
+ #SHTTPDIR=/xdev/acain/kit7/libshttp/make/$(PLATFORM)
+ #SHTTP_CFLAGS = -DSHTTP -I$(SHTTPDIR)
+ #SHTTP_OBJS = $(SHTTPDIR)/compat_unix.o $(SHTTPDIR)/io_wrap.o $(SHTTPDIR)/rsa_io.o http_shttp.o
+ 
+ # for SunOS:
+ #SHTTP_LIBS = -L$(SHTTPDIR) -lshttp -llwp
+ # for Solaris:
+ #SHTTP_LIBS = -L$(SHTTPDIR) -lshttp -lthread
+ 
+ # SSL Support
+ # SSL changes require SSLeay ... see the README.SSL file for details
+ # http://www.psy.uq.oz.au/~ftp/Crypto/
+ 
+ # SSL_CFLAGS  = -DSSL_SUPPORT -I/X11/httpd/ssleay/include
+ # SSL_OBJS    = http_ssl.o
+ # SSL_LIBS    = -L/X11/httpd/ssleay/sgi5/lib -lssl -lcrypto
+ 
  # DIGEST AUTHENTICATION 
  #
  # To enable Message Digest Authentication, define the DIGEST_AUTH flag
***************
*** 40,45 ****
--- 70,77 ----
  # although it's most likely that your realm supports one or the other.
  # To enable DES-encryption of HTTP messages via Kerberos key exchange,
  # define the KRB-ENCRYPT flag (not supported in Beta1 -- hopefully Beta2).
+ # Currently you can't have both Kerberos and SSL support because of 
+ # different des routines and des.h files.
  
  KRB4_DIR    = /xdev/mosaic/libkrb4/sun
  KRB4_LIBS   = -L$(KRB4_DIR)/lib -lkrb -ldes
***************
*** 50,58 ****
  KRB5_CFLAGS = -DKRB5 -I$(KRB5_DIR)/include -I$(KRB5_DIR)/include/krb5
  
  
! # Comment out the following two lines to exclude Kerberos support
  
  #KRB_CFLAGS = $(KRB4_CFLAGS) $(KRB5_CFLAGS)   # -DKRB-ENCRYPT
  #KRB_LIBS   = $(KRB4_LIBS) $(KRB5_LIBS)
  
  
--- 82,91 ----
  KRB5_CFLAGS = -DKRB5 -I$(KRB5_DIR)/include -I$(KRB5_DIR)/include/krb5
  
  
! # Comment out the following three lines to exclude Kerberos support
  
  #KRB_CFLAGS = $(KRB4_CFLAGS) $(KRB5_CFLAGS)   # -DKRB-ENCRYPT
+ #KRB_OBJS   = http_kerberos.o
  #KRB_LIBS   = $(KRB4_LIBS) $(KRB5_LIBS)
  
  
***************
*** 149,166 ****
  # -------------- You shouldn't have to edit anything else -----------------
  # -------------------------------------------------------------------------
  
! SEC_CFLAGS = $(MD5_CFLAGS) $(KRB_CFLAGS) 
! SEC_LIBS   = $(KRB_LIBS) 
  
  ALL_CFLAGS = $(CFLAGS) $(AUX_CFLAGS) $(SEC_CFLAGS) $(DBM_CFLAGS) $(FCGI_CFLAGS)
! ALL_LIBS = $(EXTRA_LIBS) $(SEC_LIBS) $(DBM_LIBS)
  
  
! OBJS=httpd.o http_config.o http_request.o util.o http_dir.o \
! http_alias.o http_log.o http_mime.o http_access.o http_auth.o \
! http_send.o cgi.o http_include.o rfc931.o imagemap.o \
! http_ipc.o digest.o md5.o md5c.o env.o host_config.o fdwrap.o \
! open_logfile.o allocate.o debug.o blackout.o fcgi.o
  
  .c.o: Makefile config.h portability.h constants.h
  	$(CC) -c $(ALL_CFLAGS) $<
--- 182,200 ----
  # -------------- You shouldn't have to edit anything else -----------------
  # -------------------------------------------------------------------------
  
! SEC_CFLAGS = $(MD5_CFLAGS) $(KRB_CFLAGS) $(SHTTP_CFLAGS) $(SSL_CFLAGS)
! SEC_LIBS   = $(KRB_LIBS) $(SHTTP_LIBS) $(SSL_LIBS)
  
  ALL_CFLAGS = $(CFLAGS) $(AUX_CFLAGS) $(SEC_CFLAGS) $(DBM_CFLAGS) $(FCGI_CFLAGS)
! ALL_LIBS = $(EXTRA_LIBS) $(SEC_LIBS) $(DBM_LIBS) $(FCGI_LIBS)
  
  
! OBJS = httpd.o http_config.o http_request.o util.o http_dir.o http_alias.o \
!        http_log.o http_mime.o http_access.o http_auth.o http_send.o cgi.o \
!        http_include.o rfc931.o imagemap.o http_ipc.o digest.o md5.o md5c.o \
!        env.o host_config.o fdwrap.o open_logfile.o allocate.o debug.o \
!        blackout.o http_nis.o \
!        $(FCGI_OBJS) $(KRB_OBJS) $(SSL_OBJS) $(SHTTP_OBJS) 
  
  .c.o: Makefile config.h portability.h constants.h
  	$(CC) -c $(ALL_CFLAGS) $<
diff -brc ./allocate.c /X11/blong/httpd/src//allocate.c
*** ./allocate.c	Tue Jun 25 17:06:12 1996
--- /X11/blong/httpd/src//allocate.c	Wed Jun  5 21:44:08 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * allocate.c,v 1.5 1996/04/05 18:54:28 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: allocate.c,v 1.6 1996/06/06 02:44:08 blong Exp $
   *
   ************************************************************************
   *
***************
*** 70,81 ****
  
  
    while (num) {
!     if (!(S = (char *) malloc(length * sizeof(char))))
        return 1;
  
      S[0] = '\0';
  
!     if (!(stmp = (string_item *) malloc(sizeof(string_item))))
        return 1;
  
      stmp->string = S;
--- 70,81 ----
  
  
    while (num) {
!     if (!(S = (char *) Malloc(length * sizeof(char))))
        return 1;
  
      S[0] = '\0';
  
!     if (!(stmp = (string_item *) Malloc(sizeof(string_item))))
        return 1;
  
      stmp->string = S;
diff -brc ./allocate.h /X11/blong/httpd/src//allocate.h
*** ./allocate.h	Tue Jun 25 17:06:12 1996
--- /X11/blong/httpd/src//allocate.h	Wed Jun  5 21:44:09 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * allocate.h,v 1.2 1996/04/05 18:54:29 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: allocate.h,v 1.3 1996/06/06 02:44:09 blong Exp $
   *
   ************************************************************************
   *
***************
*** 43,48 ****
--- 43,53 ----
    string_item* first;
    int num;
  } string_list;
+ 
+ /* #defs */
+ #define Malloc malloc
+ #define Free free
+ #define Realloc realloc
  
  /* Public Interface */
  int initialize_allocate(void);
Only in /X11/blong/httpd/src/: allocate.o
diff -brc ./blackout.c /X11/blong/httpd/src//blackout.c
*** ./blackout.c	Tue Jun 25 17:13:00 1996
--- /X11/blong/httpd/src//blackout.c	Tue Jun 25 17:00:02 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   * 
!  * blackout.c,v 1.3 1996/03/07 21:27:21 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   * 
!  * $Id: blackout.c,v 1.3 1996/03/07 21:27:21 blong Exp $
   *
   ************************************************************************
   *
***************
*** 51,57 ****
  
  char *bodyTag = "<BODY BGCOLOR=\"#000000\" TEXT=\"#FFFFFF\" LINK=\"#0099FF\" VLINK=\"#00FF99\"\n>";
  
! /* void (*exit_callback)(void); */
  
  
  int realWrite(int fd, char *buf, int length)
--- 51,57 ----
  
  char *bodyTag = "<BODY BGCOLOR=\"#000000\" TEXT=\"#FFFFFF\" LINK=\"#0099FF\" VLINK=\"#00FF99\"\n>";
  
! /* static void (*exit_callback)(void); */
  
  
  int realWrite(int fd, char *buf, int length)
diff -brc ./blackout.h /X11/blong/httpd/src//blackout.h
*** ./blackout.h	Tue Jun 25 17:06:12 1996
--- /X11/blong/httpd/src//blackout.h	Thu Feb  8 12:01:02 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * blackout.h,v 1.1 1996/02/08 18:01:02 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: blackout.h,v 1.1 1996/02/08 18:01:02 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: blackout.o
diff -brc ./cgi.c /X11/blong/httpd/src//cgi.c
*** ./cgi.c	Tue Jun 25 17:19:19 1996
--- /X11/blong/httpd/src//cgi.c	Tue Jun 25 17:18:33 1996
***************
*** 10,23 ****
   *
   ************************************************************************
   *
!  * cgi.c,v 1.44 1996/04/05 18:54:31 blong Exp
   *
   ************************************************************************
   *
   * cgi: keeps all script-related ramblings together.
   *
   */
  
  #include "config.h"
  #include "portability.h"
  
--- 10,26 ----
   *
   ************************************************************************
   *
!  * $Id: cgi.c,v 1.48 1996/06/12 20:35:21 acain Exp $
   *
   ************************************************************************
   *
   * cgi: keeps all script-related ramblings together.
   * 
+  * Based on NCSA HTTPd 1.3 by Rob McCool
+  *
   */
  
+ 
  #include "config.h"
  #include "portability.h"
  
***************
*** 34,44 ****
--- 37,52 ----
  # endif /* NEED_SYS_MALLOC_H */
  #endif /* NO_MALLOC_H */
  #include <string.h>
+ #include <setjmp.h>
  #include <errno.h>
  #include <sys/stat.h>
  #include <signal.h>
  #include <sys/wait.h>
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "fdwrap.h"
  #include "allocate.h"
  #include "cgi.h"
***************
*** 55,60 ****
--- 63,71 ----
  #include "http_include.h"
  #include "httpd.h"
  #include "util.h"
+ #ifdef SSL_SUPPORT
+ # include "http_ssl.h"
+ #endif /* SSL_SUPPORT */
  
  
  int pid;
***************
*** 79,85 ****
  void kill_children_timed_out() {
     kill_children(gCurrentRequest);
  }
- 
  char **create_argv(per_request *reqInfo,char *av0) {
      register int x,n;
      char **av;
--- 90,95 ----
***************
*** 173,178 ****
--- 183,198 ----
      }
      make_env_str(reqInfo,"QUERY_STRING",reqInfo->args);
  
+ #ifdef SSL_SUPPORT
+     ssl_add_cgi_vars(reqInfo);
+ #endif /* SSL_SUPPORT */
+ 
+ #ifdef SHTTP					/* added by ADC ZZZ */
+     if (reqInfo->RequestFlags & DOING_SHTTP) {
+       shttp_add_cgi_vars(reqInfo);
+     }
+ #endif /* SHTTP */
+ 
      if(content) {
          *content=0;
  	if ((reqInfo->method == M_POST) || (reqInfo->method == M_PUT)) {
***************
*** 342,347 ****
--- 362,374 ----
  	   strncpy(reqInfo->outh_www_auth,l,HUGE_STRING_LEN);
  	   reqInfo->outh_www_auth[HUGE_STRING_LEN-1] = '\0';
          }	
+ #ifdef SHTTP
+ 	else if(!strcasecmp(str,"Privacy-Enhancements")) {
+ 	  if (reqInfo->privacy_enhancements != NULL)
+ 	    freeString(reqInfo->privacy_enhancements);
+ 	  reqInfo->privacy_enhancements = dupStringP(TSW_trimbuf(l),STR_REQ);
+         }
+ #endif /* SHTTP */
          else {
              *(--l) = ':';
              for(p=0;str[p];p++);
***************
*** 510,515 ****
--- 537,547 ----
        if (nBytes >= 0) {
          if (nBytes > 0) write(p2[1], szBuf, nBytes);
          while (!nDone && (nTotalBytes < reqInfo->inh_content_length)) {
+ #ifdef SSL_SUPPORT
+ 	  if (reqInfo->RequestFlags & DOING_SSL) 
+ 	    nBytes = SSL_read(ssl_con, szBuf,HUGE_STRING_LEN);
+ 	  else
+ #endif /* SSL_SUPPORT */
  	    nBytes=read(reqInfo->in, szBuf,HUGE_STRING_LEN);
  	  if(nBytes < 1) {
  	    break;
***************
*** 623,628 ****
--- 655,665 ----
      while (1) {
  	o=0;
          while(n) {
+ #ifdef SSL_SUPPORT
+ 	    if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+ 	      w = SSL_write(ssl_con,&buf[o],n);
+ 	    } else
+ #endif /* SSL_SUPPORT */
  	    w = write(fd, buf + o,n);
  
  	    if (w < 1) {
diff -brc ./cgi.h /X11/blong/httpd/src//cgi.h
*** ./cgi.h	Tue Jun 25 17:19:58 1996
--- /X11/blong/httpd/src//cgi.h	Wed Jun  5 21:44:12 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * cgi.h,v 1.9 1996/04/05 18:54:40 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: cgi.h,v 1.10 1996/06/06 02:44:12 blong Exp $
   *
   ************************************************************************
   *
***************
*** 26,33 ****
  /* function prototypes */
  void exec_cgi_script(per_request *reqInfo);
  int cgi_stub(per_request *reqInfo, struct stat *finfo, int allow_options);
- int add_common_vars(per_request *reqInfo);
  int add_cgi_vars(per_request *reqInfo, int *content);
  void get_path_info(per_request *reqInfo, struct stat *finfo);
  int scan_cgi_header(per_request *reqInfo, int pd);
  long send_fd(per_request *reqInfo, int pd, void (*onexit)(void));
--- 26,33 ----
  /* function prototypes */
  void exec_cgi_script(per_request *reqInfo);
  int cgi_stub(per_request *reqInfo, struct stat *finfo, int allow_options);
  int add_cgi_vars(per_request *reqInfo, int *content);
+ int add_common_vars(per_request *reqInfo);
  void get_path_info(per_request *reqInfo, struct stat *finfo);
  int scan_cgi_header(per_request *reqInfo, int pd);
  long send_fd(per_request *reqInfo, int pd, void (*onexit)(void));
Only in /X11/blong/httpd/src/: cgi.o
diff -brc ./config.h /X11/blong/httpd/src//config.h
*** ./config.h	Tue Jun 25 17:06:12 1996
--- /X11/blong/httpd/src//config.h	Wed Jun 12 17:51:27 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * config.h,v 1.21 1996/03/27 20:43:51 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: config.h,v 1.24 1996/06/12 22:51:27 blong Exp $
   *
   ************************************************************************
   *
***************
*** 27,42 ****
   */
  
  /* To enable changing of the process title to the current request being
!    handled, uncomment the following.  Note: Using this will cause a
!    performance hit (though maybe not much of one).  This doesn't work
!    on all systems, either.  It is known to work under AIX3, SunOS, OSF1,
!    FreeBSD, and NetBSD. */
  
  /* #define SETPROCTITLE */
  
  /* If you have SETPROCTITLE enabled, and you are a stats fanatic, and your
!    server has a few extra clock cycles to spare, defining the following
!    will enable an RPM (requests per minute) indicator in the proc title. */
  
  #ifdef SETPROCTITLE
  #define TACHOMETER */
--- 27,44 ----
   */
  
  /* To enable changing of the process title to the current request being
!  * handled, uncomment the following.  Note: Using this will cause a
!  * performance hit (though maybe not much of one).  This doesn't work
!  * on all systems, either.  It is known to work under AIX3, SunOS, OSF1,
!  * FreeBSD, NetBSD, and Linux. 
!  */
  
  /* #define SETPROCTITLE */
  
  /* If you have SETPROCTITLE enabled, and you are a stats fanatic, and your
!  * server has a few extra clock cycles to spare, defining the following
!  * will enable an RPM (requests per minute) indicator in the proc title. 
!  */
  
  #ifdef SETPROCTITLE
  #define TACHOMETER */
***************
*** 46,121 ****
  #endif
  
  /* To not compile with built in imagemap support, comment out the following.
!    Note: It is much faster to use this then the external program, but it
!    also makes the program size of httpd larger. */
  
  #define IMAGEMAP_SUPPORT /* */
  
  /* To add an additional field -- request duration -- to the access_log.
!    This adds the duration, in seconds that the processing of this
!    request took. */
  
! /* #define LOG_DURATION */
  
  /* If you want the server to check the execute bit of an HTML file to 
!    determine if the file should be parsed, uncomment the following.
!    Using this feature will give better performance for files which
!    are not parsed without the necessity of using the magic mime type */
  
  /* #define XBITHACK */
  
  /* If you want the server to be able to parse the output of CGI scripts,
!    then define the following.  This will automatically be defined for 
!    SHTTP.  This does cause a performance degradation for CGI scripts,
!    as it requires reading the returned CGI headers off the socket one
!    byte at a time.  */
  
  /* #define CGI_SSI_HACK */
  
  /* If you would like to ensure that CGI scripts don't mess with the 
!    log files (except the error_log file), uncomment the following. */
  
  /* #define SECURE_LOGS */
  
  /* If you would like each "static" file to be sent with a Content-MD5
!    header to give clients a way of telling whether the object they
!    requested is the one they got - and hasn't been mangled along the way. 
!    Of course, no clients support this yet (to my knowledge) and this will
!    _really_ hinder performance on really big files, but that's life.  */
  
  /* #define CONTENT_MD5 */
  
  /* If you would like to specify the keyword LOCAL in your access
!    configuration file to match local address (ie, those without embedded
!    dots), uncomment the following. */
   
  /* #define LOCALHACK */
  
  /* If you would like to use NIS services for passwords and group information,
!    uncomment the following.  NOTE: DO NOT USE THIS ON OPEN NETWORKS.  The 
!    security information used in Basic Authentication involves sending the
!    password in clear text across the network on every request which requires
!    it. */
  
! /* #define NIS_SUPPORT */
  
  /* If you have a REALLY heavily loaded system, and you can't afford to
!    have a server per request(low memory?), you can compile with this i
!    option to make max_servers a hard limit. */
  
  /* #define RESOURCE_LIMIT */
  
  /* If your system doesn't support file descriptor passing, or if you
!    don't want to use it, defining the following will enable HTTPd to
!    mimic the 1.3 Forking server.  This should be defined in the system
!    specific information in portability.h, and not here. */
  
  /* #define NO_PASS */
  
  
  /* defines for new muli-child approach
!   DEFAULT_START_DAEMON defines how many children start at httpd start
!   DEFAULT_MAX_DAEMON defines how many children can start
    */
  
  #define DEFAULT_START_DAEMON    5
--- 48,133 ----
  #endif
  
  /* To not compile with built in imagemap support, comment out the following.
!  * Note: It is much faster to use this then the external program, but it
!  * also makes the program size of httpd larger. 
!  */
  
  #define IMAGEMAP_SUPPORT /* */
  
  /* To add an additional field -- request duration -- to the access_log.
!  * This adds the duration, in seconds that the processing of this
!  * request took. 
!  */
  
! #define LOG_TIMES /* */
  
  /* If you want the server to check the execute bit of an HTML file to 
!  * determine if the file should be parsed, uncomment the following.
!  * Using this feature will give better performance for files which
!  * are not parsed without the necessity of using the magic mime type 
!  */
  
  /* #define XBITHACK */
  
  /* If you want the server to be able to parse the output of CGI scripts,
!  * then define the following.  This will automatically be defined for 
!  * SHTTP.  This does cause a performance degradation for CGI scripts,
!  * as it requires reading the returned CGI headers off the socket one
!  * byte at a time.  
!  */
  
  /* #define CGI_SSI_HACK */
  
  /* If you would like to ensure that CGI scripts don't mess with the 
!  * log files (except the error_log file), uncomment the following. 
!  */
  
  /* #define SECURE_LOGS */
  
  /* If you would like each "static" file to be sent with a Content-MD5
!  * header to give clients a way of telling whether the object they
!  * requested is the one they got - and hasn't been mangled along the way. 
!  * Of course, no clients support this yet (to my knowledge) and this will
!  * _really_ hinder performance on really big files, but that's life.  
!  */
  
  /* #define CONTENT_MD5 */
  
  /* If you would like to specify the keyword LOCAL in your access
!  * configuration file to match local address (ie, those without embedded
!  * dots), uncomment the following. 
!  */
   
  /* #define LOCALHACK */
  
  /* If you would like to use NIS services for passwords and group information,
!  * uncomment the following.  NOTE: DO NOT USE THIS ON OPEN NETWORKS.  The 
!  * security information used in Basic Authentication involves sending the
!  * password in clear text across the network on every request which requires
!  * it. 
!  */
  
! #define NIS_SUPPORT 
  
  /* If you have a REALLY heavily loaded system, and you can't afford to
!  * have a server per request(low memory?), you can compile with this i
!  * option to make max_servers a hard limit. 
!  */
  
  /* #define RESOURCE_LIMIT */
  
  /* If your system doesn't support file descriptor passing, or if you
!  * don't want to use it, defining the following will enable HTTPd to
!  * mimic the 1.3 Forking server.  This should be defined in the system
!  * specific information in portability.h, and not here. 
!  */
  
  /* #define NO_PASS */
  
  
  /* defines for new muli-child approach
!  * DEFAULT_START_DAEMON defines how many children start at httpd start
!  * DEFAULT_MAX_DAEMON defines how many children can start
   */
  
  #define DEFAULT_START_DAEMON    5
***************
*** 122,132 ****
  #define DEFAULT_MAX_DAEMON      10
  
  /* defines for debugging purposes
!    PROFILE to set the server up to profile the code 
!    QUANTIFY is a profiler from Pure software
!    PURIFY is a memory checker from Pure software
!    DEBUG compiles in extra debugging code (debug.c, mostly)
! */
  
  /* #define DEBUG  */
  /* #define PROFILE  */
--- 134,144 ----
  #define DEFAULT_MAX_DAEMON      10
  
  /* defines for debugging purposes
!  * PROFILE to set the server up to profile the code 
!  * QUANTIFY is a profiler from Pure software
!  * PURIFY is a memory checker from Pure software
!  * DEBUG compiles in extra debugging code (debug.c, mostly)
!  */
  
  /* #define DEBUG  */
  /* #define PROFILE  */
***************
*** 138,149 ****
  #define SHELL_PATH "/bin/sh"
  
  /* DEFAULT_PATH defines the default search PATH handed to CGI scripts
!    if there isn't one in the environment when HTTPd runs */
  
  #define DEFAULT_PATH "/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/local/bin:."
  
  /* The following define default values for options which can be over-
!    ridden at run time via command-line or configuration files */
  
  #define HTTPD_ROOT "/usr/local/etc/httpd"
  
--- 150,163 ----
  #define SHELL_PATH "/bin/sh"
  
  /* DEFAULT_PATH defines the default search PATH handed to CGI scripts
!  * if there isn't one in the environment when HTTPd runs 
!  */
  
  #define DEFAULT_PATH "/bin:/usr/bin:/usr/ucb:/usr/bsd:/usr/local/bin:."
  
  /* The following define default values for options which can be over-
!  * ridden at run time via command-line or configuration files 
!  */
  
  #define HTTPD_ROOT "/usr/local/etc/httpd"
  
***************
*** 158,163 ****
--- 172,181 ----
  #define DEFAULT_PORT 80
  #define DEFAULT_USER "#-1"
  #define DEFAULT_GROUP "#-1"
+ 
+ #ifdef SSL_SUPPORT
+ # define DEFAULT_SSL_PORT 443
+ #endif /* SSL_SUPPORT */
  
  #define DEFAULT_XFERLOG "logs/access_log"
  #define DEFAULT_AGENTLOG "logs/agent_log"
diff -brc ./constants.h /X11/blong/httpd/src//constants.h
*** ./constants.h	Tue Jun 25 17:23:53 1996
--- /X11/blong/httpd/src//constants.h	Wed Jun 12 17:45:11 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * constants.h,v 1.54 1996/04/05 18:54:42 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: constants.h,v 1.58 1996/06/12 21:52:13 acain Exp $
   *
   ************************************************************************
   *
***************
*** 37,42 ****
--- 37,51 ----
  
  #include <stdio.h>
  #include <netinet/in.h>
+ #ifdef LOG_TIMES
+ # include <sys/times.h>
+ # include <sys/time.h>
+ # include <time.h>
+ #endif /* LOG_TIMES */
+ #include "global.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ #endif /* SHTTP */
  
  #define TRUE  1
  #define FALSE 0
***************
*** 52,57 ****
--- 61,76 ----
  # define HTTP_TIME_FORMAT "%a, %d %b %Y %T GMT" 
  #endif /* NEXT */
  
+ #ifdef SSL_SUPPORT 
+ # define SSL_VERSION "SSLeay/0.5.1"
+ #else
+ # define SSL_VERSION ""
+ #endif /* SSL_SUPPORT */
+ #ifdef SHTTP
+ # define SHTTP_TITLE "SHTTP"
+ #else
+ # define SHTTP_TITLE ""
+ #endif /* SHTTP */
  #define SERVER_VERSION "NCSA/1.5.2"
  #define SERVER_SOURCE "NCSA/1.5.2"
  #define SERVER_PROTOCOL "HTTP/1.0"
***************
*** 166,171 ****
--- 185,194 ----
  #define IMAGEMAP_MAGIC_TYPE      "text/x-imagemap"
  #define BLACKOUT_MAGIC_TYPE 	 "text/x-httpd-black"
  
+ #ifdef SHTTP
+ #define SHTTP_MAGIC_TYPE	 "application/x-s-http-response"  /* pre-enhanced s-http response */
+ #endif /* SHTTP */
+ 
  /* For directory indexing */
  #define BY_PATH 			0
  #define BY_TYPE 			1
***************
*** 229,234 ****
--- 252,262 ----
  
      char *on_deny[METHODS];
  
+ #ifdef SHTTP
+     list_el *shttp_auth_lines;
+     char *shttp_privacy_enhancements;
+ #endif /* SHTTP */
+ 
      char auth_type[MAX_STRING_LEN];
      char auth_name[MAX_STRING_LEN];
      char auth_pwfile[MAX_STRING_LEN];
***************
*** 277,283 ****
  
  #define PH_HTTPD_CONF      1
  #define PH_SRM_CONF        2
- #define PH_PEM_CONF        3
  
  
  /* Configurate data structure (for what's configurable per host) 
--- 305,310 ----
***************
*** 329,335 ****
  /* --------- Per request Data Structure ------------- */
   
  /* Request Flags */
- #define DOING_PGP   1
  #define DOING_SHTTP 2
  #define DOING_SSL   3
   
--- 356,361 ----
***************
*** 402,408 ****
    int num_env;
    int max_env;
    char **env;
-   int *env_len;
   
  /* Client Information */
    char *remote_host;
--- 428,433 ----
***************
*** 418,423 ****
--- 443,459 ----
    sock_buf *cgi_buf;
    per_host *hostInfo;
    struct in_addr address_info;
+  
+ #ifdef SHTTP
+ /* S-HTTP Information */
+   msginfo *shttp_info;
+   char *privacy_enhancements;
+ #endif /* SHTTP */
+ 
+ #ifdef LOG_TIMES
+   struct timeval time_recv, time_process, time_send;
+   struct tms times_recv;
+ #endif /* LOG_TIMES */
  
  /* Linked List of requests */
    struct _per_request *next;
Only in /X11/blong/httpd/src/: core.1
Only in /X11/blong/httpd/src/: core.2
Only in /X11/blong/httpd/src/: debug.o
diff -brc ./digest.c /X11/blong/httpd/src//digest.c
*** ./digest.c	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//digest.c	Thu May 23 15:15:31 1996
***************
*** 25,36 ****
  #endif /* NO_STDLIB_H */
  #include <sys/types.h>
  #include <sys/time.h>
- #include <string.h>
  #include <fcntl.h>
  #include <ctype.h>
  #ifdef DBM_SUPPORT
! # ifndef _DBMSUPPORT_H  /* moronic OSs which don't protect their own include */
! #  define _DBMSUPPORT_H  /* files from being multiply included */
  #  include <ndbm.h>
  # endif /* _DBMSUPPORT_H */
  #endif /* DBM_SUPPORT */
--- 25,36 ----
  #endif /* NO_STDLIB_H */
  #include <sys/types.h>
  #include <sys/time.h>
  #include <fcntl.h>
+ #include <string.h>
  #include <ctype.h>
  #ifdef DBM_SUPPORT
! # ifndef _DBMSUPPORT_H
! #  define _DBMSUPPORT_H 
  #  include <ndbm.h>
  # endif /* _DBMSUPPORT_H */
  #endif /* DBM_SUPPORT */
***************
*** 42,58 ****
  #include "http_auth.h"
  #include "http_mime.h"
  #include "util.h"
  
  int get_digest(per_request *reqInfo, char *user, char *realm, char *digest, 
  	       security_data* sec) 
  {
      FILE *f;
-     char errstr[MAX_STRING_LEN];
      char l[MAX_STRING_LEN];
      char w[MAX_STRING_LEN];
      char r[MAX_STRING_LEN];
  
-     if (reqInfo->auth_digestfile_type == AUTHFILETYPE_STANDARD) {
  	if (reqInfo->auth_digestfile == NULL) {
  	    sprintf (errstr, "No digest file specified for URL: %s\n",
  	             reqInfo->url);
--- 42,86 ----
  #include "http_auth.h"
  #include "http_mime.h"
  #include "util.h"
+ #include "md5.h"
+ #ifdef NIS_SUPPORT
+ # include "http_nis.h"
+ #endif /* NIS_SUPPORT */
  
+ int dbm_get_digest(per_request *reqInfo, char *user, char *realm, char *digest)
+ {
+     DBM* db;
+     datum dtKey, dtRec;
+     char szBuf[2*MAX_STRING_LEN];
+     char errstr[MAX_STRING_LEN];
+  
+     if(!(db = DBM_Open(reqInfo->auth_digestfile, O_RDONLY, 0))) {
+       sprintf(errstr,"Could not open user file %s",reqInfo->auth_digestfile);
+       die(reqInfo,SC_SERVER_ERROR,errstr);
+     }
+     sprintf (szBuf, "%s:%s", user, realm);
+     dtKey.dptr = szBuf;
+     dtKey.dsize = strlen(szBuf);
+     dtRec = dbm_fetch(db, dtKey);
+     DBM_Close(db);
+     if (dtRec.dptr) {
+       strncpy(digest, dtRec.dptr, dtRec.dsize);
+       digest[dtRec.dsize] = '\0';
+       return 1;
+     }
+     return 0;
+ }
+ 
  int get_digest(per_request *reqInfo, char *user, char *realm, char *digest, 
  	       security_data* sec) 
  {
+   if (reqInfo->auth_digestfile_type == AUTHFILETYPE_STANDARD) {
      FILE *f;
      char l[MAX_STRING_LEN];
      char w[MAX_STRING_LEN];
      char r[MAX_STRING_LEN];
+     char errstr[MAX_STRING_LEN];
    
      if (reqInfo->auth_digestfile == NULL) {
        sprintf (errstr, "No digest file specified for URL: %s\n",
  	       reqInfo->url);
***************
*** 88,146 ****
      }
  #ifdef DBM_SUPPORT
      else if (reqInfo->auth_digestfile_type == AUTHFILETYPE_DBM) {
! 	DBM* db;
! 	datum dtKey, dtRec;
! 	char szBuf[2*MAX_STRING_LEN];
! 
! 	if(!(db = DBM_Open(reqInfo->auth_digestfile, O_RDONLY, 0))) {
! 	    sprintf(errstr,"Could not open user file %s",reqInfo->auth_digestfile);
! 	    die(reqInfo,SC_SERVER_ERROR,errstr);
  	}
- 	sprintf (szBuf, "%s:%s", user, realm);
- 	dtKey.dptr = szBuf;
- 	dtKey.dsize = strlen(szBuf);
- 	dtRec = dbm_fetch(db, dtKey);
- 	DBM_Close(db);
- 	if (dtRec.dptr) {
- 	    strncpy(digest, dtRec.dptr, dtRec.dsize);
- 	    digest[dtRec.dsize] = '\0';
- 	    return 1;
- 	}
- 	else
- 	    return 0;
-     }
  #endif /* DBM_SUPPORT */
  #ifdef NIS_SUPPORT
      else if (reqInfo->auth_pwfile_type == AUTHFILETYPE_NIS) {
!       char    *domain,
!               *digest,
!               *resptr,
!               szBuf[2*MAX_STRING_LEN];
!       int     yperr,
!               resize;
! 
!       if (init_nis(&domain) != 0)
!               return 0;
! 
!       if (strcmp(reqInfo->auth_digestfile, "+"))
!               digest = reqInfo->auth_digestfile;
!       else
!               digest = "digest";
! 
!       (void) sprintf(szBuf, "%s:%s", user, realm);
! 
!       yperr = yp_match(domain, digest, szBuf, strlen(szBuf), &resptr, &resize);
!       if (yperr == 0) {
!               getword(w, resptr, ':');
!               getword(r, resptr, ':');
!               if (strcmp(w, user) == 0 && strcmp(w, realm) == 0) {
!                       getword(w, resptr, ':');
!                       (void) strcpy(digest, w);
!                       return 1;
                }
-       }
-       return 0;
-     } 
  #endif /* NIS_SUPPORT */
      else 
        die(reqInfo,SC_SERVER_ERROR,"Invalid password file type");
--- 116,128 ----
    }
  #ifdef DBM_SUPPORT
    else if (reqInfo->auth_digestfile_type == AUTHFILETYPE_DBM) {
!     return dbm_get_digest(reqInfo,user,realm,digest);
    }
  #endif /* DBM_SUPPORT */
  #ifdef NIS_SUPPORT
    else if (reqInfo->auth_pwfile_type == AUTHFILETYPE_NIS) {
!     return nis_get_digest(reqInfo,user,realm,digest);
    } 
  #endif /* NIS_SUPPORT */
      else 
        die(reqInfo,SC_SERVER_ERROR,"Invalid password file type");
***************
*** 147,153 ****
      return 0;
  }
  
! void Digest_Construct401(per_request *reqInfo, char *s, int stale, char* auth_name)
  {
  	char timestamp[32];
  	char h_opaque[33];
--- 129,136 ----
      return 0;
  }
  
! void Digest_Construct401(per_request *reqInfo, char *s, int stale, 
! 			 char* auth_name)
  {
    char timestamp[32];
    char h_opaque[33];
***************
*** 154,181 ****
  	char opaque[MAX_STRING_LEN];
  
  	/*
! 		Note that the domain field isn't being sent at all.  If
! 		it were to be sent, it would probably need to be read
! 		from the config files.
! 
! 		We're using timestamps as our nonce value.
  	*/
  
  	/*
! 		Grab the timestamp (for the nonce).  Also, then construct
! 		the opaque value.
  	*/
  	sprintf(timestamp, "%d", time(NULL));
  	sprintf(opaque, "%s:%s:%s", auth_name, timestamp, reqInfo->remote_ip);
  	md5(opaque, h_opaque);
  
! 	if (stale)
! 	{
  		sprintf(s, "Digest realm=\"%s\" nonce=\"%s\" opaque=\"%s\" stale=TRUE",
  			auth_name, timestamp, h_opaque);
! 	}
! 	else
! 	{
  		sprintf(s, "Digest realm=\"%s\" nonce=\"%s\" opaque=\"%s\"",
  			auth_name, timestamp, h_opaque);
  	}
--- 137,161 ----
    char opaque[MAX_STRING_LEN];
    
    /*
!    * Note that the domain field isn't being sent at all.  If
!    * it were to be sent, it would probably need to be read
!    * from the config files.
!    *
!    * We're using timestamps as our nonce value.
     */
    
    /*
!    * Grab the timestamp (for the nonce).  Also, then construct
!    * the opaque value.
     */
    sprintf(timestamp, "%d", time(NULL));
    sprintf(opaque, "%s:%s:%s", auth_name, timestamp, reqInfo->remote_ip);
    md5(opaque, h_opaque);
    
!   if (stale) {
        sprintf(s, "Digest realm=\"%s\" nonce=\"%s\" opaque=\"%s\" stale=TRUE",
  	      auth_name, timestamp, h_opaque);
!   } else {
      sprintf(s, "Digest realm=\"%s\" nonce=\"%s\" opaque=\"%s\"",
  	    auth_name, timestamp, h_opaque);
    }
***************
*** 191,212 ****
      char opaque[MAX_STRING_LEN];
      char errstr[MAX_STRING_LEN];
  
!     char *p;
!     char *q;
      
      time_t time_now;
      time_t time_nonce;
  
! /*    user[0]; */	/* assume that we won't succeed */
  
-     username[0] = 0;
-     realm[0] = 0;
-     nonce[0] = 0;
-     uri[0] = 0;
-     response[0] = 0;
-     opaque[0] = 0;
-     p = q = NULL;
-     
      p = reqInfo->inh_auth_line;
      while (isspace(*p))	{
  	p++;
--- 171,189 ----
    char opaque[MAX_STRING_LEN];
    char errstr[MAX_STRING_LEN];
    
!   char *p = NULL;
!   char *q = NULL;
    
    time_t time_now;
    time_t time_nonce;
    
!   username[0] = '\0';
!   realm[0] = '\0';
!   nonce[0] = '\0';
!   uri[0] = '\0';
!   response[0] = '\0';
!   opaque[0] = '\0';
    
    p = reqInfo->inh_auth_line;
    while (isspace(*p)) {
      p++;
***************
*** 292,298 ****
  	}
  
  	/*
! 	   Skip to the next keyword value pair, or the end
  	   */
  	while (*p && (*p != ',')) {
  	    p++;
--- 269,275 ----
      }
      
      /*
!      * Skip to the next keyword value pair, or the end
       */
      while (*p && (*p != ',')) {
        p++;
***************
*** 312,318 ****
  	char h_all[32 + 1];
  	
  	/*
! 	   First, check to make sure the nonce is not stale
  	   */
  
  	time_nonce = atoi(nonce);
--- 289,295 ----
      char h_all[32 + 1];
      
      /*
!      * First, check to make sure the nonce is not stale
       */
      
      time_nonce = atoi(nonce);
***************
*** 328,334 ****
  	}
  
  	/*
! 	   Check to make sure that the opaque string is valid.
  	   */
  	{
  	    char h_opaque[33];
--- 305,311 ----
      }
      
      /*
!      * Check to make sure that the opaque string is valid.
       */
      {
        char h_opaque[33];
***************
*** 345,352 ****
  	}
  	
  	/*
! 	   Here we should check to make sure that the URI
! 	   given is valid, but a simple strcmp may not be reliable.
  	   */
  #if 0
  	if (0 != strcmp(reqInfo->url, uri)) {
--- 322,329 ----
      }
      
      /*
!      * Here we should check to make sure that the URI
!      * given is valid, but a simple strcmp may not be reliable.
       */
  #if 0
      if (0 != strcmp(reqInfo->url, uri)) {
***************
*** 357,364 ****
  #endif /* 0 */
  	
  	/*
! 	   Now, check to make sure that the MD5 digest given
! 	   is correct.
  	   */
  	
  	if (!get_digest(reqInfo,username, realm, h_a1, sec)) {
--- 334,341 ----
  #endif /* 0 */
      
      /*
!      * Now, check to make sure that the MD5 digest given
!      * is correct.
       */
      
      if (!get_digest(reqInfo,username, realm, h_a1, sec)) {
Only in /X11/blong/httpd/src/: digest.o
diff -brc ./env.c /X11/blong/httpd/src//env.c
*** ./env.c	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//env.c	Wed Jun  5 21:44:17 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  *env.c,v 1.20 1996/04/05 18:54:44 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  *$Id: env.c,v 1.23 1996/06/06 02:44:17 blong Exp $
   *
   ************************************************************************
   *
***************
*** 31,36 ****
--- 31,37 ----
  #include "http_request.h"
  #include "http_log.h"
  #include "allocate.h"
+ #include "util.h"
  
  /* Older version, required external help.  Newer version should be self 
   *  contained for easier extensibility
***************
*** 39,56 ****
   */
  
  /* This will change the value of an environment variable to *value
!    if found.  Returns TRUE if the replace took place, FALSE otherwise */
  
  int  replace_env_str(per_request *reqInfo, char *name, char *value)
  {
      register int i, len;
   
!     for (i = 0, len = strlen(name); reqInfo->env[i]; i++) {
  	if (strncmp(reqInfo->env[i], name, len) == 0) {
! 	    free(reqInfo->env[i]);
  	    if (i < reqInfo->num_env) {
  		reqInfo->env[i] = reqInfo->env[--(reqInfo->num_env)];
- 		reqInfo->env_len[i] = reqInfo->env_len[reqInfo->num_env];
  		reqInfo->env[reqInfo->num_env] = NULL;
  	    } 
  	    else {
--- 40,58 ----
   */
  
  /* This will change the value of an environment variable to *value
!  * if found.  Returns TRUE if the replace took place, FALSE otherwise 
!  */
  
  int replace_env_str(per_request *reqInfo, char *name, char *value)
  {
      register int i, len;
   
!     len = strlen(name);
!     for (i = 0; (reqInfo->env[i] && (i < reqInfo->num_env)); i++) {
  	if (strncmp(reqInfo->env[i], name, len) == 0) {
! 	    freeString(reqInfo->env[i]);
  	    if (i < reqInfo->num_env) {
  		reqInfo->env[i] = reqInfo->env[--(reqInfo->num_env)];
  		reqInfo->env[reqInfo->num_env] = NULL;
  	    } 
  	    else {
***************
*** 69,87 ****
  void free_env(per_request *reqInfo) {
      int x;
     
!     for(x=0;reqInfo->env[x];x++)
          freeString(reqInfo->env[x]);
!     free(reqInfo->env);
!     free(reqInfo->env_len);
      reqInfo->env = NULL;
  }
  
  
  /* If the environment variable has already been set, this will append
!    the value to it, of the form "name=old, new" 
!    Assumes that "header" is a pointer to a string that is longer than
!    the string it contains
! */
  
  int merge_header(per_request *reqInfo, char *header, char *value) 
  {
--- 71,88 ----
  void free_env(per_request *reqInfo) {
      int x;
     
!     for(x=0;(x < reqInfo->num_env) && (reqInfo->env[x]);x++)
          freeString(reqInfo->env[x]);
!     Free(reqInfo->env);
      reqInfo->env = NULL;
  }
  
  
  /* If the environment variable has already been set, this will append
!  * the value to it, of the form "name=old, new" 
!  * Assumes that "header" is a pointer to a string that is longer than
!  * the string it contains
!  */
  
  int merge_header(per_request *reqInfo, char *header, char *value) 
  {
***************
*** 98,104 ****
      for(ndx = 0, t=reqInfo->env; *t; ++t, ndx++) {
          if(!strncmp(*t,header,l)) {
              lt = strlen(*t);
! 	    if ((lt + len + 2) > reqInfo->env_len[ndx]) {
   	      tmp = reqInfo->env[ndx];
  	      if ((lt+len+2) > HUGE_STRING_LEN) {
  		reqInfo->env[ndx] = newString(lt+len+2,STR_REQ);
--- 99,105 ----
      for(ndx = 0, t=reqInfo->env; *t; ++t, ndx++) {
          if(!strncmp(*t,header,l)) {
              lt = strlen(*t);
! 	    if ((lt + len + 2) > sizeofString(*t)) {
   	      tmp = reqInfo->env[ndx];
  	      if ((lt+len+2) > HUGE_STRING_LEN) {
  		reqInfo->env[ndx] = newString(lt+len+2,STR_REQ);
***************
*** 126,132 ****
  
  int make_env_str(per_request *reqInfo, char *name, char *value) 
  {
-     int n;
      char tmp[HUGE_STRING_LEN];
  
      if (value == NULL) {
--- 127,132 ----
***************
*** 136,151 ****
        return 0;
      }
      if (reqInfo->env == NULL) {
! 	if (!(reqInfo->env = (char **) malloc(ENV_BEG_SIZE * sizeof(char *)))
! 	    || !(reqInfo->env_len = (int*) malloc(ENV_BEG_SIZE * sizeof(int))))
  	    die(reqInfo,SC_NO_MEMORY,"make_env_str:malloc");
  	reqInfo->max_env = ENV_BEG_SIZE;
      }
      if ((reqInfo->num_env+1) >= reqInfo->max_env) {
! 	if (!(reqInfo->env = (char **) realloc(reqInfo->env, 
! 	       ((reqInfo->max_env+ENV_INC_SIZE) * sizeof(char *)))) 
! 	    || !(reqInfo->env_len = (int*) realloc(reqInfo->env_len, 
! 			(reqInfo->max_env + ENV_INC_SIZE) * sizeof(int))))
  	    die(reqInfo,SC_NO_MEMORY,"make_env_str:realloc");
  	reqInfo->max_env += ENV_INC_SIZE;
      }
--- 136,148 ----
        return 0;
      }
      if (reqInfo->env == NULL) {
! 	if (!(reqInfo->env = (char **) Malloc(ENV_BEG_SIZE * sizeof(char *))))
  	    die(reqInfo,SC_NO_MEMORY,"make_env_str:malloc");
  	reqInfo->max_env = ENV_BEG_SIZE;
      }
      if ((reqInfo->num_env+1) >= reqInfo->max_env) {
! 	if (!(reqInfo->env = (char **) Realloc(reqInfo->env, 
! 	       ((reqInfo->max_env+ENV_INC_SIZE) * sizeof(char *)))))
  	    die(reqInfo,SC_NO_MEMORY,"make_env_str:realloc");
  	reqInfo->max_env += ENV_INC_SIZE;
      }
***************
*** 153,165 ****
      strncat(tmp,"=",HUGE_STRING_LEN - strlen(tmp));
      strncat(tmp,value,HUGE_STRING_LEN - strlen(tmp));
      reqInfo->env[reqInfo->num_env] = dupStringP(tmp,STR_REQ); 
-     reqInfo->env_len[reqInfo->num_env] = 
- 			      sizeofString(reqInfo->env[reqInfo->num_env]);
-   
      reqInfo->num_env++;
      reqInfo->env[reqInfo->num_env] = NULL; 
  
      return 1;
  }
  
  /* Debugging dump of environment array */
--- 150,176 ----
      strncat(tmp,"=",HUGE_STRING_LEN - strlen(tmp));
      strncat(tmp,value,HUGE_STRING_LEN - strlen(tmp));
      reqInfo->env[reqInfo->num_env] = dupStringP(tmp,STR_REQ); 
      reqInfo->num_env++;
      reqInfo->env[reqInfo->num_env] = NULL; 
  
      return 1;
+ }
+ 
+ /* return_env_value()
+  *   returns a pointer to the value portion of env var given
+  *   the var to look for.
+  */
+ char* return_env_value(per_request *reqInfo, char *var)
+ {
+   int len = strlen(var);
+   int x,i;
+ 
+   for(x=0; reqInfo->env[x] && (x < reqInfo->num_env); x++) {
+     i = ind(reqInfo->env[x],'=');
+     if ((i == len) && !(strncmp(reqInfo->env[x],var,i)))
+       return &(reqInfo->env[x][i+1]);
+   }
+   return NULL;
  }
  
  /* Debugging dump of environment array */
diff -brc ./env.h /X11/blong/httpd/src//env.h
*** ./env.h	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//env.h	Wed Jun 12 16:11:50 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * env.h,v 1.8 1995/11/28 09:01:43 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: env.h,v 1.9 1996/06/12 18:26:08 blong Exp $
   *
   ************************************************************************
   *
***************
*** 37,42 ****
--- 37,44 ----
  int merge_header(per_request *reqInfo, char *h, char *v);
  void free_env(per_request *reqInfo);
  int replace_env_str(per_request *reqInfo, char *name, char *value);
+ char* return_env_value(per_request *reqInfo, char *var);
+ 
  
  #endif /* _ENV_H_ */
  
Only in /X11/blong/httpd/src/: env.o
diff -brc ./fcgi.c /X11/blong/httpd/src//fcgi.c
*** ./fcgi.c	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//fcgi.c	Wed Jun  5 21:44:19 1996
***************
*** 4,15 ****
   *  Copyright (C) 1995 Open Market, Inc.
   *  All rights reserved.
   *
-  *  This file contains proprietary and confidential information and
-  *  remains the unpublished property of Open Market, Inc. Use,
-  *  disclosure, or reproduction is prohibited except as permitted by
-  *  express written license agreement with Open Market, Inc.
   ************************************************************************
!  * $Id: fcgi.c,v 1.3 1996/03/25 22:21:10 blong Exp $
   ************************************************************************
   *
   * fcgi.c -- interface to FCGI
--- 4,11 ----
   *  Copyright (C) 1995 Open Market, Inc.
   *  All rights reserved.
   *
   ************************************************************************
!  * $Id: fcgi.c,v 1.7 1996/06/06 02:44:19 blong Exp $
   ************************************************************************
   *
   * fcgi.c -- interface to FCGI
***************
*** 53,58 ****
--- 49,55 ----
  #include <assert.h>
  #include <stdlib.h>
  #include <string.h>
+ #include <ctype.h>
  #include <errno.h>
  #include <limits.h>
  #include <sys/types.h>
***************
*** 83,88 ****
--- 80,86 ----
  #include "http_config.h"
  #include "http_auth.h"
  #include "http_alias.h"
+ #include "http_send.h"
  #include "util.h"
  /*-----------------dependent types-----------------------*/
  typedef per_request WS_Request;
***************
*** 411,417 ****
  } FastCgiInfo;
  
  int fastCgiInit = 0;
! static WS_Request *hackRequest = NULL;
  FastCgiServerInfo *fastCgiServers = NULL;
  FastCgiInfo *globalInfoPtr = NULL;
  int ht_openmax = 128;
--- 409,415 ----
  } FastCgiInfo;
  
  int fastCgiInit = 0;
! /* static WS_Request *hackRequest = NULL; */
  FastCgiServerInfo *fastCgiServers = NULL;
  FastCgiInfo *globalInfoPtr = NULL;
  int ht_openmax = 128;
***************
*** 2395,2401 ****
  static int ConnectionComplete(WS_Request *reqPtr, FastCgiInfo *infoPtr)
  {
      int errorCode, len;
!     FastCgiServerInfo *serverInfoPtr = infoPtr->serverPtr;
  
      /*
       * Get the connection status.
--- 2393,2399 ----
  static int ConnectionComplete(WS_Request *reqPtr, FastCgiInfo *infoPtr)
  {
      int errorCode, len;
! /*    FastCgiServerInfo *serverInfoPtr = infoPtr->serverPtr; */
  
      /*
       * Get the connection status.
***************
*** 2446,2452 ****
  {
      FastCgiServerInfo *serverInfoPtr;
      FastCgiInfo *infoPtr;
!     int scriptTimeout;
      OS_IpcAddr *ipcAddrPtr;
      struct stat finfo;
  
--- 2444,2450 ----
  {
      FastCgiServerInfo *serverInfoPtr;
      FastCgiInfo *infoPtr;
! /*    int scriptTimeout; */
      OS_IpcAddr *ipcAddrPtr;
      struct stat finfo;
  
***************
*** 2776,2782 ****
  
  void OS_EnvironFree(char **envPtr)
  {
!   int i;
    char **tmp = envPtr;
    while (*tmp) {
      free(*tmp);
--- 2774,2780 ----
  
  void OS_EnvironFree(char **envPtr)
  {
! /*  int i; */
    char **tmp = envPtr;
    while (*tmp) {
      free(*tmp);
***************
*** 2787,2793 ****
  void OS_EnvString(char **envPtr, char *name, char *value)
  {
      char *buf;
!     int size;
      buf = (char *)Malloc(strlen(name) + strlen(value) + 2);
      sprintf(buf, "%s=%s", name, value);
      *envPtr = buf;
--- 2785,2791 ----
  void OS_EnvString(char **envPtr, char *name, char *value)
  {
      char *buf;
! /*    int size; */
      buf = (char *)Malloc(strlen(name) + strlen(value) + 2);
      sprintf(buf, "%s=%s", name, value);
      *envPtr = buf;
***************
*** 2820,2826 ****
  {
      FastCgiServerInfo *serverInfoPtr = NULL;
      FcgiProcessInfo *procInfoPtr;
!     int i, new;
  
      serverInfoPtr = FastCgiServerInfoLookup(ePath);
      if (serverInfoPtr)
--- 2818,2825 ----
  {
      FastCgiServerInfo *serverInfoPtr = NULL;
      FcgiProcessInfo *procInfoPtr;
!     int i;
! /*    int new; */
  
      serverInfoPtr = FastCgiServerInfoLookup(ePath);
      if (serverInfoPtr)
***************
*** 2976,2982 ****
  static void FcgiProgramExit(FcgiProcessInfo *processInfoPtr, int status)
  {
      FastCgiServerInfo *serverInfoPtr = processInfoPtr->serverInfoPtr;
!     time_t restartTime, timeNow;
  
      serverInfoPtr->numFailures++;
      processInfoPtr->pid = -1;
--- 2975,2981 ----
  static void FcgiProgramExit(FcgiProcessInfo *processInfoPtr, int status)
  {
      FastCgiServerInfo *serverInfoPtr = processInfoPtr->serverInfoPtr; 
! /*    time_t restartTime, timeNow; */
  
      serverInfoPtr->numFailures++;
      processInfoPtr->pid = -1;
***************
*** 3090,3096 ****
  	processInfoPtr++;
      }
      while (1) { /* looping to detect and reborn any dead child */
!         int status;
  	    
  	sleep(serverInfoPtr->restartDelay);
  	if (serverInfoPtr->restartOnExit == FALSE)
--- 3089,3095 ----
  	processInfoPtr++;
      }
      while (1) { /* looping to detect and reborn any dead child */
! /*        int status; */
  	    
  	sleep(serverInfoPtr->restartDelay);
  	if (serverInfoPtr->restartOnExit == FALSE)
***************
*** 3165,3173 ****
      int affinity = 0;
      int restartDelay = FCGI_DEFAULT_RESTART_DELAY;
      char *execPath;
!     char temp[200];
      FastCgiServerInfo *serverInfoPtr = NULL;
!     FcgiProcessInfo *processInfoPtr;
      int i;
      int listenFd = -1;
      char *namePtr;
--- 3164,3172 ----
      int affinity = 0;
      int restartDelay = FCGI_DEFAULT_RESTART_DELAY;
      char *execPath;
! /*    char temp[200]; */
      FastCgiServerInfo *serverInfoPtr = NULL;
! /*    FcgiProcessInfo *processInfoPtr; */
      int i;
      int listenFd = -1;
      char *namePtr;
***************
*** 3179,3185 ****
      int argc;
      char **argv;
      int envCount;
!     int listenSock = -1;
      SetErrorLogFd(host, 1);
  
      argv = ParseAppClassArgs(arg, &argc);
--- 3178,3184 ----
      int argc;
      char **argv;
      int envCount;
! /*    int listenSock = -1; */
      SetErrorLogFd(host, 1);
  
      argv = ParseAppClassArgs(arg, &argc);
diff -brc ./fcgi.h /X11/blong/httpd/src//fcgi.h
*** ./fcgi.h	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//fcgi.h	Wed May 15 16:09:49 1996
***************
*** 9,15 ****
   *  disclosure, or reproduction is prohibited except as permitted by
   *  express written license agreement with Open Market, Inc.
   ************************************************************************
!  * $Id: fcgi.h,v 1.2 1996/03/25 22:21:30 blong Exp $
   ************************************************************************
   *
   * fcgi.c -- interface to FCGI
--- 9,15 ----
   *  disclosure, or reproduction is prohibited except as permitted by
   *  express written license agreement with Open Market, Inc.
   ************************************************************************
!  * $Id: fcgi.h,v 1.3 1996/05/15 21:09:49 blong Exp $
   ************************************************************************
   *
   * fcgi.c -- interface to FCGI
***************
*** 21,26 ****
--- 21,28 ----
  
  #ifndef _FCGI_H
  #define _FCGI_H 1
+ 
+ #define FCGI_MAGIC_TYPE "application/x-httpd-fcgi"
  
  /* External Functions */
  int FastCgiHandler(per_request *reqPtr);
Only in /X11/blong/httpd/src/: fcgi.o
diff -brc ./fdwrap.c /X11/blong/httpd/src//fdwrap.c
*** ./fdwrap.c	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//fdwrap.c	Wed Jun  5 21:44:21 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * fdwrap.c,v 1.15 1996/04/05 18:54:46 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: fdwrap.c,v 1.16 1996/06/06 02:44:21 blong Exp $
   *
   ************************************************************************
   *
***************
*** 45,50 ****
--- 45,51 ----
  #include "fdwrap.h"
  #include "host_config.h"
  #include "http_log.h"
+ #include "allocate.h"
  
  static FDTABLE* FdTab;
  static int nSize;
***************
*** 70,76 ****
      int ndx;
  
      /* take care of failure here */
!     FdTab = (FDTABLE*) malloc (INITIAL_TABSIZE * sizeof(FDTABLE));
      if (!FdTab) {
        fprintf(stderr,
          "HTTPd: Could not allocate memory for file descriptor tracking\n");
--- 71,77 ----
      int ndx;
  
      /* take care of failure here */
!     FdTab = (FDTABLE*) Malloc (INITIAL_TABSIZE * sizeof(FDTABLE));
      if (!FdTab) {
        fprintf(stderr,
          "HTTPd: Could not allocate memory for file descriptor tracking\n");
***************
*** 287,291 ****
  
  void DestroyFdTab(void)
  {
!   free (FdTab);
  }
--- 288,292 ----
  
  void DestroyFdTab(void)
  {
!   Free (FdTab);
  }
diff -brc ./fdwrap.h /X11/blong/httpd/src//fdwrap.h
*** ./fdwrap.h	Tue Jun 25 17:06:13 1996
--- /X11/blong/httpd/src//fdwrap.h	Tue Nov 28 03:01:45 1995
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * fdwrap.h,v 1.5 1995/11/28 09:01:45 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: fdwrap.h,v 1.5 1995/11/28 09:01:45 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: fdwrap.o
diff -brc ./host_config.c /X11/blong/httpd/src//host_config.c
*** ./host_config.c	Tue Jun 25 17:06:14 1996
--- /X11/blong/httpd/src//host_config.c	Wed Jun 12 16:11:50 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  *host_config.c,v 1.20 1996/04/05 18:54:47 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  *$Id: host_config.c,v 1.22 1996/06/12 20:35:23 acain Exp $
   *
   ************************************************************************
   *
***************
*** 29,34 ****
--- 29,35 ----
  #include "http_alias.h"
  #include "http_mime.h"
  #include "http_request.h"
+ #include "allocate.h"
  #include "util.h"
  
  per_host* gConfiguration;
***************
*** 36,42 ****
  per_host* create_host_conf(per_host *hostInfo, int virtual) {
    per_host *newInfo, *tmpInfo;
  
!   newInfo = (per_host *) malloc(sizeof(per_host));
  
    newInfo->httpd_conf = 0;
    newInfo->srm_conf = 0;
--- 37,43 ----
  per_host* create_host_conf(per_host *hostInfo, int virtual) {
    per_host *newInfo, *tmpInfo;
  
!   newInfo = (per_host *) Malloc(sizeof(per_host));
  
    newInfo->httpd_conf = 0;
    newInfo->srm_conf = 0;
***************
*** 103,128 ****
  
    while (host != NULL) {
      close_logs(host);
!     if (host->httpd_conf & HC_ERROR_FNAME) free(host->error_fname);
!     if (host->httpd_conf & HC_XFER_FNAME) free(host->xfer_fname);
!     if (host->httpd_conf & HC_AGENT_FNAME) free(host->agent_fname);
!     if (host->httpd_conf & HC_REFERER_FNAME) free(host->referer_fname);
!     if (host->httpd_conf & HC_REFERER_IGNORE) free(host->referer_ignore);
!     if (host->httpd_conf & HC_SERVER_ADMIN) free(host->server_admin);
!     if (host->httpd_conf & HC_SERVER_HOSTNAME) free(host->server_hostname);
!     if (host->httpd_conf & HC_SRM_CONFNAME) free(host->srm_confname);
!     if (host->httpd_conf & HC_ANNOT_SERVER) free(host->annotation_server);
!     if (host->srm_conf & SRM_USER_DIR) free(host->user_dir);
!     if (host->srm_conf & SRM_INDEX_NAMES) free(host->index_names);
!     if (host->srm_conf & SRM_ACCESS_NAME) free(host->access_name);
!     if (host->srm_conf & SRM_DOCUMENT_ROOT) free(host->document_root);
!     if (host->srm_conf & SRM_DEFAULT_TYPE) free(host->default_type);
!     if (host->srm_conf & SRM_DEFAULT_ICON) free(host->default_icon);
      if (host->srm_conf & SRM_TRANSLATIONS) free_aliases(host->translations);
      if (host->srm_conf & SRM_DOCERRORS) free_doc_errors(host);
      
      tmp = host->next;
!     free(host);
      host = tmp;
    }
  }
--- 104,129 ----
  
    while (host != NULL) {
      close_logs(host);
!     if (host->httpd_conf & HC_ERROR_FNAME) Free(host->error_fname);
!     if (host->httpd_conf & HC_XFER_FNAME) Free(host->xfer_fname);
!     if (host->httpd_conf & HC_AGENT_FNAME) Free(host->agent_fname);
!     if (host->httpd_conf & HC_REFERER_FNAME) Free(host->referer_fname);
!     if (host->httpd_conf & HC_REFERER_IGNORE) Free(host->referer_ignore);
!     if (host->httpd_conf & HC_SERVER_ADMIN) Free(host->server_admin);
!     if (host->httpd_conf & HC_SERVER_HOSTNAME) Free(host->server_hostname);
!     if (host->httpd_conf & HC_SRM_CONFNAME) Free(host->srm_confname);
!     if (host->httpd_conf & HC_ANNOT_SERVER) Free(host->annotation_server);
!     if (host->srm_conf & SRM_USER_DIR) Free(host->user_dir);
!     if (host->srm_conf & SRM_INDEX_NAMES) Free(host->index_names);
!     if (host->srm_conf & SRM_ACCESS_NAME) Free(host->access_name);
!     if (host->srm_conf & SRM_DOCUMENT_ROOT) Free(host->document_root);
!     if (host->srm_conf & SRM_DEFAULT_TYPE) Free(host->default_type);
!     if (host->srm_conf & SRM_DEFAULT_ICON) Free(host->default_icon);
      if (host->srm_conf & SRM_TRANSLATIONS) free_aliases(host->translations);
      if (host->srm_conf & SRM_DOCERRORS) free_doc_errors(host);
      
      tmp = host->next;
!     Free(host);
      host = tmp;
    }
  }
***************
*** 158,204 ****
      switch (option) {
      case HC_ERROR_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->error_fname);
        hostInfo->error_fname = tmp;
        break;
      case HC_XFER_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->xfer_fname);
        hostInfo->xfer_fname = tmp;
        break;
      case HC_AGENT_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->agent_fname);
        hostInfo->agent_fname = tmp;
        break;
      case HC_REFERER_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->referer_fname);
        hostInfo->referer_fname = tmp;
        break;
      case HC_REFERER_IGNORE:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->referer_ignore);
        hostInfo->referer_ignore = tmp;
        break;
      case HC_SERVER_ADMIN:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->server_admin);
        hostInfo->server_admin = tmp;
        break;
      case HC_SERVER_HOSTNAME:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->server_hostname);
        hostInfo->server_hostname = tmp;
        break;
      case HC_SRM_CONFNAME:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->srm_confname);
        hostInfo->srm_confname = tmp;
        break;
      case HC_ANNOT_SERVER:
        if (hostInfo->httpd_conf & option) 
! 	free(hostInfo->annotation_server);
        hostInfo->annotation_server = tmp;
        break;
      }
--- 159,205 ----
      switch (option) {
      case HC_ERROR_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->error_fname);
        hostInfo->error_fname = tmp;
        break;
      case HC_XFER_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->xfer_fname);
        hostInfo->xfer_fname = tmp;
        break;
      case HC_AGENT_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->agent_fname);
        hostInfo->agent_fname = tmp;
        break;
      case HC_REFERER_FNAME:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->referer_fname);
        hostInfo->referer_fname = tmp;
        break;
      case HC_REFERER_IGNORE:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->referer_ignore);
        hostInfo->referer_ignore = tmp;
        break;
      case HC_SERVER_ADMIN:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->server_admin);
        hostInfo->server_admin = tmp;
        break;
      case HC_SERVER_HOSTNAME:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->server_hostname);
        hostInfo->server_hostname = tmp;
        break;
      case HC_SRM_CONFNAME:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->srm_confname);
        hostInfo->srm_confname = tmp;
        break;
      case HC_ANNOT_SERVER:
        if (hostInfo->httpd_conf & option) 
! 	Free(hostInfo->annotation_server);
        hostInfo->annotation_server = tmp;
        break;
      }
***************
*** 208,240 ****
      switch (option) {
      case SRM_USER_DIR:
        if (hostInfo->srm_conf & option)
! 	free(hostInfo->user_dir);
        hostInfo->user_dir = tmp;
        break;
      case SRM_INDEX_NAMES:
        if (hostInfo->srm_conf & option)
! 	free(hostInfo->index_names);
        hostInfo->index_names = tmp;
        break;
      case SRM_ACCESS_NAME:
        if (hostInfo->srm_conf & option)
! 	free(hostInfo->access_name);
        hostInfo->access_name = tmp;
        break;
      case SRM_DOCUMENT_ROOT:
        if (hostInfo->srm_conf & option)
! 	free(hostInfo->document_root);
        hostInfo->document_root = tmp;
        hostInfo->doc_root_len = strlen(tmp);
        break;
      case SRM_DEFAULT_TYPE:
        if (hostInfo->srm_conf & option)
! 	free(hostInfo->default_type);
        hostInfo->default_type = tmp;
        break;
      case SRM_DEFAULT_ICON:
        if (hostInfo->srm_conf & option)
! 	free(hostInfo->default_icon);
        hostInfo->default_icon = tmp;
        break;
      }
--- 209,241 ----
      switch (option) {
      case SRM_USER_DIR:
        if (hostInfo->srm_conf & option)
! 	Free(hostInfo->user_dir);
        hostInfo->user_dir = tmp;
        break;
      case SRM_INDEX_NAMES:
        if (hostInfo->srm_conf & option)
! 	Free(hostInfo->index_names);
        hostInfo->index_names = tmp;
        break;
      case SRM_ACCESS_NAME:
        if (hostInfo->srm_conf & option)
! 	Free(hostInfo->access_name);
        hostInfo->access_name = tmp;
        break;
      case SRM_DOCUMENT_ROOT:
        if (hostInfo->srm_conf & option)
! 	Free(hostInfo->document_root);
        hostInfo->document_root = tmp;
        hostInfo->doc_root_len = strlen(tmp);
        break;
      case SRM_DEFAULT_TYPE:
        if (hostInfo->srm_conf & option)
! 	Free(hostInfo->default_type);
        hostInfo->default_type = tmp;
        break;
      case SRM_DEFAULT_ICON:
        if (hostInfo->srm_conf & option)
! 	Free(hostInfo->default_icon);
        hostInfo->default_icon = tmp;
        break;
      }
diff -brc ./host_config.h /X11/blong/httpd/src//host_config.h
*** ./host_config.h	Tue Jun 25 17:06:14 1996
--- /X11/blong/httpd/src//host_config.h	Wed Jun 12 17:45:11 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * host_config.h,v 1.9 1995/11/28 09:01:47 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: host_config.h,v 1.10 1996/06/12 21:52:15 acain Exp $
   *
   ************************************************************************
   *
***************
*** 45,58 ****
  #define SRM_DEFAULT_ICON   32
  #define SRM_TRANSLATIONS   64
  #define SRM_DOCERRORS	   128
- 
- /* PEM_CONF OPTS */
- #define PEMC_PEM_ENCRYPT   1
- #define PEMC_PEM_DECRYPT   2
- #define PEMC_PEM_ENTITY    4
- #define PEMC_PGP_ENCRYPT   8
- #define PEMC_PGP_DECRYPT   16
- #define PEMC_PGP_ENTITY    32
  
  /* globals defined in this module */
  extern per_host *gConfiguration;
--- 45,50 ----
Only in /X11/blong/httpd/src/: host_config.o
diff -brc ./http_access.c /X11/blong/httpd/src//http_access.c
*** ./http_access.c	Tue Jun 25 17:06:14 1996
--- /X11/blong/httpd/src//http_access.c	Wed Jun  5 21:44:24 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_access.c,v 1.78 1996/04/05 18:54:49 blong Exp
   *
   ************************************************************************
   * 
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_access.c,v 1.81 1996/06/06 02:44:24 blong Exp $
   *
   ************************************************************************
   * 
***************
*** 307,315 ****
--- 307,351 ----
     
      if(sec[x].num_auth[reqInfo->method])
          *allow_options=x;
+ #ifdef SHTTP
+     if(sec[x].shttp_privacy_enhancements)
+ 	*other = x;
+ #endif /* SHTTP */
        
  }
  
+ int check_sym_link(per_request *reqInfo, char *file, char options, 
+ 		   char *errstr)
+ {
+   struct stat lfi,fi;
+   
+   if (lstat(file,&lfi) != 0) {
+     sprintf(errstr,"HTTPd: can't lstat %s, errno = %d",file, errno);
+     return 0;
+   }
+   /* 05-15-95 blong
+    * If not a directory?  Shouldn't this be S_ISLNK? 
+    */
+ /*  if (!(S_ISDIR(lfi.st_mode))) { */
+   if (S_ISLNK(lfi.st_mode)) {
+     if (options & OPT_SYM_OWNER) {
+       if (stat(file,&fi) != 0) {
+ 	sprintf(errstr,"HTTPd: can't stat %s, errno = %d",file, errno);
+ 	return 0;
+       }
+       /* Check valid for OPT_SYM_OWNER (follow link if owner) */
+       if (fi.st_uid != lfi.st_uid) {
+ 	sprintf(errstr,"HTTPd: link owner doesn't match for %s",file);
+ 	return 0;
+       }
+     } else {
+       sprintf(errstr,"HTTPd: will not follow link %s",file);
+       return 0;
+     }
+   }
+   return 1;
+ }
+ 
  void evaluate_access(per_request *reqInfo,struct stat *finfo,int *allow,
  		     char *allow_options) 
  {
***************
*** 333,340 ****
--- 369,378 ----
  
      reqInfo->auth_user[0] = '\0';
      reqInfo->auth_group[0] = '\0';
+     /* Clear .htaccess content type information from previous time*/
      reset_mime_vars();
  
+     /* Clear directory info structs */
      for(x=0;x<num_dirs;x++) {
        opts[x] = OPT_ALL;
        override[x] = OR_ALL;
***************
*** 344,363 ****
      reqInfo->bSatisfiedDomain = 0;
      
      n=num_dirs-1;
      for(x=0;x<num_sec;x++) {
!         if(is_matchexp(sec[x].d)) {
!             if(!strcmp_match(path,sec[x].d)) {
                  for(y=0;y<num_dirs;y++) {
!                     if(!(sec[x].opts & OPT_UNSET))
                          opts[y] = sec[x].opts;
                      override[y] = sec[x].override;
                  }
                  check_dir_access(reqInfo,x,&will_allow,&need_auth,&need_enhance);
              }
!         }
!         else if(!strncmp(path,sec[x].d,strlen(sec[x].d))) {
              for(y=count_dirs(sec[x].d) - 1;y<num_dirs;y++) {
!                 if(!(sec[x].opts & OPT_UNSET))
                      opts[y] = sec[x].opts;
                  override[y] = sec[x].override;
              }
--- 382,403 ----
      reqInfo->bSatisfiedDomain = 0;
      
      n=num_dirs-1;
+ /* Go through the security information structure, and if its a match, add it
+  * to the current structures (opts, override)
+  */
      for(x=0;x<num_sec;x++) {
!       if (is_matchexp(sec[x].d)) {
!         if (!strcmp_match(path,sec[x].d)) {
            for(y=0;y<num_dirs;y++) {
!             if (!(sec[x].opts & OPT_UNSET))
                opts[y] = sec[x].opts;
              override[y] = sec[x].override;
            }
            check_dir_access(reqInfo,x,&will_allow,&need_auth,&need_enhance);
          }
!       } else if (!strncmp(path,sec[x].d,strlen(sec[x].d))) {
          for(y=count_dirs(sec[x].d) - 1;y<num_dirs;y++) {
!           if (!(sec[x].opts & OPT_UNSET))
              opts[y] = sec[x].opts;
            override[y] = sec[x].override;
          }
***************
*** 367,424 ****
  	  strcpy(reqInfo->outh_location,sec[x].on_deny[reqInfo->method]);
          }
      }
!     if((override[n]) || (!(opts[n] & OPT_SYM_LINKS)) || 
         (opts[n] & OPT_SYM_OWNER)) {
  	for(x=0;x<num_dirs;x++) {
  	    y = num_sec;
  	    make_dirstr(path,x+1,d);
! 	    if((!(opts[x] & OPT_SYM_LINKS)) || (opts[x] & OPT_SYM_OWNER)) {
! 		struct stat lfi,fi;
! 		
! 		if(lstat(d,&lfi) != 0)
! 		{
! 		    sprintf(errstr,"HTTPd: can't lstat %s, errno = %d",d, errno);
  		    log_error(errstr,reqInfo->hostInfo->error_log);
  		    *allow=FA_DENY;
  		    *allow_options = OPT_NONE;
  		    return;
  		}
- 		if(!(S_ISDIR(lfi.st_mode))) {
- 		    if(opts[x] & OPT_SYM_OWNER) {
- 			if(stat(d,&fi) != 0)
- 			{
- 			    sprintf(errstr,"HTTPd: can't stat %s, errno = %d",d, errno);
- 			    log_error(errstr,reqInfo->hostInfo->error_log);
- 			    *allow=FA_DENY;
- 			    *allow_options = OPT_NONE;
- 			    return;
  			}
! 			if(fi.st_uid != lfi.st_uid)
! 			    goto bong;
! 		    }
! 		    else {
! 		      bong:
! 			sprintf(errstr,"HTTPd: will not follow link %s",d);
! 			log_error(errstr,reqInfo->hostInfo->error_log);
! 			*allow=FA_DENY;
! 			*allow_options = OPT_NONE;
! 			return;
! 		    }
! 		}
! 	    }
  	    if(override[x]) {
  		parse_htaccess(reqInfo,d,override[x]);
  		if(num_sec != y) {
  		    for(z=count_dirs(sec[y].d) - 1;z<num_dirs;z++) {
  			if(!(sec[y].opts & OPT_UNSET))
  			    opts[z] = sec[y].opts;
  			override[z] = sec[y].override;
  		    }
! 		    if ((sec[y].num_auth[reqInfo->method] > 0) || 
  			(sec[y].num_allow[reqInfo->method] > 0) ||
  			(sec[y].num_deny[reqInfo->method] > 0) ||
  			(sec[y].num_referer_allow[reqInfo->method] > 0) ||
! 			(sec[y].num_referer_deny[reqInfo->method] > 0))
  			check_dir_access(reqInfo,y,&will_allow,&need_auth,&need_enhance);
  	                if (!will_allow && sec[y].on_deny[reqInfo->method]) {
  	                  strcpy(reqInfo->outh_location,
--- 407,444 ----
  	strcpy(reqInfo->outh_location,sec[x].on_deny[reqInfo->method]);
        }
      }
! /* Only check local information (ie, .htaccess) if override allowed on
!  * final object, if sym links are not allowed, or if owned symlinks are 
!  */
!     if ((override[n]) || (!(opts[n] & OPT_SYM_LINKS)) || 
          (opts[n] & OPT_SYM_OWNER)) {
        for(x=0;x<num_dirs;x++) {
  	y = num_sec;
  	make_dirstr(path,x+1,d);
! 	if ((!(opts[x] & OPT_SYM_LINKS)) || (opts[x] & OPT_SYM_OWNER)) {
! 	  if (!check_sym_link(reqInfo,d,opts[x],errstr)) {
  	    log_error(errstr,reqInfo->hostInfo->error_log);
  	    *allow=FA_DENY;
  	    *allow_options = OPT_NONE;
  	    return;
            }
  	}
! 	/* If overrides allowed for this directory, read the .htaccess file */
  	if(override[x]) {
  	  parse_htaccess(reqInfo,d,override[x]);
  	  if(num_sec != y) {
+ 	    /* if any security info was added, add it to our info here */
  	    for(z=count_dirs(sec[y].d) - 1;z<num_dirs;z++) {
  	      if(!(sec[y].opts & OPT_UNSET))
  		opts[z] = sec[y].opts;
  	      override[z] = sec[y].override;
  	    }
! 	    /* hmm, just run the directory check anyways */
! /*	    if ((sec[y].num_auth[reqInfo->method] > 0) || 
  	    (sec[y].num_allow[reqInfo->method] > 0) ||
  	    (sec[y].num_deny[reqInfo->method] > 0) ||
  	    (sec[y].num_referer_allow[reqInfo->method] > 0) ||
! 	    (sec[y].num_referer_deny[reqInfo->method] > 0)) */
  	    check_dir_access(reqInfo,y,&will_allow,&need_auth,&need_enhance);
  	    if (!will_allow && sec[y].on_deny[reqInfo->method]) {
  	      strcpy(reqInfo->outh_location,
***************
*** 428,472 ****
  	    }
  	}
      }
      if((!(S_ISDIR(finfo->st_mode))) && 
         ((!(opts[n] & OPT_SYM_LINKS)) || (opts[n] & OPT_SYM_OWNER))) {
!         struct stat fi,lfi;
!         if(lstat(path,&fi)!=0)
! 	{
! 	    sprintf(errstr,"HTTPd: can't lstat %s, errno = %d",path, errno);
  	    log_error(errstr,reqInfo->hostInfo->error_log);
  	    *allow=FA_DENY;
  	    *allow_options = OPT_NONE;
  	    return;
  	}
-         if(!(S_ISREG(fi.st_mode))) {
-             if(opts[n] & OPT_SYM_OWNER) {
-                 if(stat(path,&lfi)!=0)
- 		{
- 		    sprintf(errstr,"HTTPd: can't stat %s, errno = %d",path, errno);
- 		    log_error(errstr,reqInfo->hostInfo->error_log);
- 		    *allow=FA_DENY;
- 		    *allow_options = OPT_NONE;
- 		    return;
  		}
!                 if(fi.st_uid != lfi.st_uid)
!                     goto gong;
              }
!             else {
!               gong:
!                 sprintf(errstr,"HTTPd: will not follow link %s",path);
!                 log_error(errstr,reqInfo->hostInfo->error_log);
!                 *allow=FA_DENY;
!                 *allow_options = OPT_NONE;
!                 return;
!             }
!         }
!     }
      *allow = will_allow;
      if(will_allow) {
          *allow_options = opts[num_dirs-1];
          if ((need_auth >= 0) && (sec[need_auth].bSatisfy == SATISFY_ALL)) {
  	    reqInfo->bSatisfiedDomain = 0;
  	    check_auth(reqInfo,&sec[need_auth], reqInfo->inh_auth_line);
  	}
      } else if ((need_auth >= 0) && (sec[need_auth].bSatisfy == SATISFY_ANY)) {
--- 448,482 ----
  	}
        }
      }
+ /* If the requested object isn't a directory, then test it too */
      if((!(S_ISDIR(finfo->st_mode))) && 
         ((!(opts[n] & OPT_SYM_LINKS)) || (opts[n] & OPT_SYM_OWNER))) {
!       if (!check_sym_link(reqInfo,path,opts[n],errstr)) {
  	log_error(errstr,reqInfo->hostInfo->error_log);
  	*allow=FA_DENY;
  	*allow_options = OPT_NONE;
  	return;
        }
      }
! #ifdef SHTTP
!     /* This needs to be done first so rejection is processed with the right
!      * options.
!      */
!     if (sec[need_enhance].shttp_privacy_enhancements != NULL) {
!       freeString(reqInfo->privacy_enhancements);
!       reqInfo->privacy_enhancements = 
! 	dupStringP(sec[need_enhance].shttp_privacy_enhancements,STR_REQ);
      }
! #endif /* SHTTP */
      *allow = will_allow;
      if(will_allow) {
        *allow_options = opts[num_dirs-1];
        if ((need_auth >= 0) && (sec[need_auth].bSatisfy == SATISFY_ALL)) {
  	reqInfo->bSatisfiedDomain = 0;
+ 	/* 
+ 	 * Check authorization information: If this returns, everything
+ 	 * is ok
+ 	 */
  	check_auth(reqInfo,&sec[need_auth], reqInfo->inh_auth_line);
        }
      } else if ((need_auth >= 0) && (sec[need_auth].bSatisfy == SATISFY_ANY)) {
***************
*** 482,520 ****
      register int x,y,m;
  
      for(x=0;x<num_sec;x++) {
-         /*free(sec[x].d);*/
          for(m=0;m<METHODS;m++) {
              for(y=0;y<sec[x].num_allow[m];y++)
!                 free(sec[x].allow[m][y]);
              for(y=0;y<sec[x].num_deny[m];y++)
!                 free(sec[x].deny[m][y]);
              for(y=0;y<sec[x].num_auth[m];y++)
!                 free(sec[x].auth[m][y]);
              for(y=0;y<sec[x].num_referer_allow[m];y++)
! 		free(sec[x].referer_allow[m][y]);
              for(y=0;y<sec[x].num_referer_deny[m];y++)
! 		free(sec[x].referer_deny[m][y]);
!             free(sec[x].on_deny[m]);
          }
- /*        if(sec[x].auth_type)
-             free(sec[x].auth_type);
-         if(sec[x].auth_name)
-             free(sec[x].auth_name);
-         if(sec[x].auth_pwfile)
-             free(sec[x].auth_pwfile);
-         if(sec[x].auth_grpfile)
-             free(sec[x].auth_grpfile);
- #ifdef DIGEST_AUTH
-         if(sec[x].auth_digestfile)
-             free(sec[x].auth_digestfile);
- #endif*/ /* DIGEST_AUTH */
      }
  }
  
  
  /* This function should reset the security data structure to contain only
!    the information given in the access configuration file.  It should be 
!    called after any transactions */
  
  void reset_security(void) 
  {
--- 492,518 ----
    register int x,y,m;
    
    for(x=0;x<num_sec;x++) {
      for(m=0;m<METHODS;m++) {
        for(y=0;y<sec[x].num_allow[m];y++)
! 	Free(sec[x].allow[m][y]);
        for(y=0;y<sec[x].num_deny[m];y++)
! 	Free(sec[x].deny[m][y]);
        for(y=0;y<sec[x].num_auth[m];y++)
! 	Free(sec[x].auth[m][y]);
        for(y=0;y<sec[x].num_referer_allow[m];y++)
! 	Free(sec[x].referer_allow[m][y]);
        for(y=0;y<sec[x].num_referer_deny[m];y++)
! 	Free(sec[x].referer_deny[m][y]);
!       if (sec[x].on_deny[m]) Free(sec[x].on_deny[m]);
      }
    }
  }
  
  
  /* This function should reset the security data structure to contain only
!  * the information given in the access configuration file.  It should be 
!  * called after any transactions 
!  */
  
  void reset_security(void) 
  {
***************
*** 521,554 ****
      register int x,y,m;
  
      for(x=num_sec_config;x<num_sec;x++) {
-         /*free(sec[x].d);*/
          for(m=0;m<METHODS;m++) {
              for(y=0;y<sec[x].num_allow[m];y++)
!                 free(sec[x].allow[m][y]);
              for(y=0;y<sec[x].num_deny[m];y++)
!                 free(sec[x].deny[m][y]);
              for(y=0;y<sec[x].num_auth[m];y++)
!                 free(sec[x].auth[m][y]);
              for(y=0;y<sec[x].num_referer_allow[m];y++)
! 		free(sec[x].referer_allow[m][y]);
              for(y=0;y<sec[x].num_referer_deny[m];y++)
! 		free(sec[x].referer_deny[m][y]);
!             if (sec[x].on_deny[m]) free(sec[x].on_deny[m]);
          }
- /*        if(sec[x].auth_type)
-             free(sec[x].auth_type);
-         if(sec[x].auth_name)
-             free(sec[x].auth_name);
-         if(sec[x].auth_pwfile)
-             free(sec[x].auth_pwfile);
-         if(sec[x].auth_grpfile)
-             free(sec[x].auth_grpfile);
- #ifdef DIGEST_AUTH
-         if(sec[x].auth_digestfile)
-             free(sec[x].auth_digestfile);
- #endif*/ /* DIGEST_AUTH */
      }
  
     num_sec = num_sec_config;
  }
- 
--- 519,538 ----
    register int x,y,m;
    
    for(x=num_sec_config;x<num_sec;x++) {
      for(m=0;m<METHODS;m++) {
        for(y=0;y<sec[x].num_allow[m];y++)
! 	Free(sec[x].allow[m][y]);
        for(y=0;y<sec[x].num_deny[m];y++)
! 	Free(sec[x].deny[m][y]);
        for(y=0;y<sec[x].num_auth[m];y++)
! 	Free(sec[x].auth[m][y]);
        for(y=0;y<sec[x].num_referer_allow[m];y++)
! 	Free(sec[x].referer_allow[m][y]);
        for(y=0;y<sec[x].num_referer_deny[m];y++)
! 	Free(sec[x].referer_deny[m][y]);
!       if (sec[x].on_deny[m]) Free(sec[x].on_deny[m]);
      }
    }
    
    num_sec = num_sec_config;
  }
diff -brc ./http_access.h /X11/blong/httpd/src//http_access.h
*** ./http_access.h	Tue Jun 25 17:06:15 1996
--- /X11/blong/httpd/src//http_access.h	Thu Feb 22 17:46:41 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_access.h,v 1.12 1996/02/22 23:46:41 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_access.h,v 1.12 1996/02/22 23:46:41 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_access.o
diff -brc ./http_alias.c /X11/blong/httpd/src//http_alias.c
*** ./http_alias.c	Tue Jun 25 17:06:15 1996
--- /X11/blong/httpd/src//http_alias.c	Wed May 29 23:31:17 1996
***************
*** 29,34 ****
--- 29,35 ----
  #include "http_config.h"
  #include "http_log.h"
  #include "http_request.h"
+ #include "allocate.h"
  #include "util.h"
  
  /* To send stat() information to cgi.c */
***************
*** 38,48 ****
    int x;
  
    for (x=0; x < trans->num_aliases ; x++) {
!     free(trans->aliases[x].fake);
!     free(trans->aliases[x].real);
    }
!   free(trans->aliases);
!   free(trans);
  }
  
  void add_lookup(per_host *host, char *fake, char *real, int type) {
--- 39,49 ----
    int x;
  
    for (x=0; x < trans->num_aliases ; x++) {
!     Free(trans->aliases[x].fake);
!     Free(trans->aliases[x].real);
    }
!   Free(trans->aliases);
!   Free(trans);
  }
  
  void add_lookup(per_host *host, char *fake, char *real, int type) {
***************
*** 50,57 ****
    int n;
  
    if (translations == NULL) {
!     translations = (lookup *) malloc(sizeof(lookup));
!     translations->aliases = (lookupRec *) malloc(TRANS_BEG_SIZE * 
  						 sizeof(lookupRec));
      translations->num_aliases = 0;
      translations->max_aliases = TRANS_BEG_SIZE;
--- 51,58 ----
    int n;
  
    if (translations == NULL) {
!     translations = (lookup *) Malloc(sizeof(lookup));
!     translations->aliases = (lookupRec *) Malloc(TRANS_BEG_SIZE * 
  						 sizeof(lookupRec));
      translations->num_aliases = 0;
      translations->max_aliases = TRANS_BEG_SIZE;
diff -brc ./http_alias.h /X11/blong/httpd/src//http_alias.h
*** ./http_alias.h	Tue Jun 25 17:06:15 1996
--- /X11/blong/httpd/src//http_alias.h	Wed Feb 14 17:46:08 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_alias.h,v 1.9 1995/11/28 09:01:52 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_alias.h,v 1.9 1995/11/28 09:01:52 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_alias.o
diff -brc ./http_auth.c /X11/blong/httpd/src//http_auth.c
*** ./http_auth.c	Tue Jun 25 17:06:14 1996
--- /X11/blong/httpd/src//http_auth.c	Wed Jun 12 16:11:51 1996
***************
*** 31,36 ****
--- 31,37 ----
  #endif /* NO_MALLOC_H */
  #include <string.h>
  #include <signal.h>
+ #include <setjmp.h>
  #include <fcntl.h>
  #include <ctype.h>
  #include <sys/types.h>
***************
*** 41,49 ****
  #  include <ndbm.h>
  # endif /* _DBMSUPPORT_H */
  #endif /* DBM_SUPPORT */
- #ifdef NIS_SUPPORT
- # include <rpcsvc/ypclnt.h>
- #endif /* NIS_SUPPORT */
  #if defined(KRB4) || defined(KRB5)
  # define HAVE_KERBEROS
  #endif /* defined(KRB4) || defined(KRB5) */
--- 42,47 ----
***************
*** 54,59 ****
--- 52,61 ----
  # include <krb5.h>
  #endif /* KRB5 */
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "fdwrap.h"
  #include "allocate.h"
  #include "http_auth.h" 
***************
*** 64,107 ****
  #include "http_request.h"
  #include "util.h"
  #include "digest.h"
- 
  #ifdef HAVE_KERBEROS
! #define T 1
! #define NIL 0
! char* index();
! char krb_authreply[2048];
! extern char *remote_logname; 
! /* extern char out_auth_header[]; */
! 
! /* Table for converting binary values to and from hexadecimal */
! static char hex[] = "0123456789abcdef";
! static char dec[256] = {
!     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*   0 -  15 */
!     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  16 -  37 */
!     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* ' ' - '/' */
!     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0,   /* '0' - '?' */
!     0,10,11,12,13,14,15, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* '@' - 'O' */
!     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 'P' - '_' */
!     0,10,11,12,13,14,15, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* '`' - 'o' */
!     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 'p' - DEL */
! };
  #endif /* HAVE_KERBEROS */
  
! #ifdef KRB4
! #define MAX_KDATA_LEN MAX_KTXT_LEN
! char k4_srvtab[MAX_STRING_LEN] = "";
! static des_cblock session;      /* Our session key */
! static des_key_schedule schedule; /* Schedule for our session key */
! AUTH_DAT kerb_kdata;
! #endif /* KRB4 */
  
- #ifdef KRB5
- #ifndef MAX_KDATA_LEN
- #define MAX_KDATA_LEN 2048     
- #endif /* MAX_KDATA_LEN */
- char k5_srvtab[MAX_STRING_LEN] = "";
- #endif /* KRB5 */
- 
  #ifdef RADIUS_AUTH
  /* Experimental RADIUS authentication 
   */
--- 66,80 ----
  #include "http_request.h"
  #include "util.h"
  #include "digest.h"
  #ifdef HAVE_KERBEROS
! # include "http_kerberos.h"
  #endif /* HAVE_KERBEROS */
+ #ifdef NIS_SUPPORT
+ # include "http_nis.h"
+ #endif /* NIS_SUPPORT */
  
! #define DEBUG 1
  
  #ifdef RADIUS_AUTH
  /* Experimental RADIUS authentication 
   */
***************
*** 108,144 ****
  int testpass (char * user, char * clear_pw, char * servername);
  #endif /* RADIUS_AUTH */
  
! #ifdef NIS_SUPPORT
! int
! init_nis(char **dom)
! {
!       static int      init = 0;
!       static char     *domain;
!       int             yperr;
! 
!       if (init == 0) {
!               yperr = yp_get_default_domain(&domain);
!               if (yperr == 0)
!                       init++;
!       }
! 
!       if (init) {
!               *dom = domain;
!               return 0;
!       }
!       return 1;
! }
! #endif /* NIS_SUPPORT */
! 
  int get_pw(per_request *reqInfo, char *user, char *pw, security_data* sec) 
  { 
!     FILE *f; 
      char errstr[MAX_STRING_LEN]; 
-     char l[MAX_STRING_LEN];
      char w[MAX_STRING_LEN]; 
      struct stat finfo;
- 
-     if (reqInfo->auth_pwfile_type == AUTHFILETYPE_STANDARD) { 	
  	/* From Conrad Damon (damon@netserver.standford.edu), 	 
  	   Don't start cfg_getline loop if auth_pwfile is a directory. */
  
--- 81,99 ----
  int testpass (char * user, char * clear_pw, char * servername);
  #endif /* RADIUS_AUTH */
  
! /* get_pw()
!  *    Returns 0 if failure, 1 if success
!  *    On success, returns password in *pw
!  */
  int get_pw(per_request *reqInfo, char *user, char *pw, security_data* sec) 
  { 
! 
!     if (reqInfo->auth_pwfile_type == AUTHFILETYPE_STANDARD) { 	
        char errstr[MAX_STRING_LEN]; 
        char w[MAX_STRING_LEN]; 
+       char l[MAX_STRING_LEN];
+       FILE *f; 
        struct stat finfo;
  	/* From Conrad Damon (damon@netserver.standford.edu), 	 
  	   Don't start cfg_getline loop if auth_pwfile is a directory. */
  
***************
*** 167,219 ****
      } 
  #ifdef DBM_SUPPORT
      else if(reqInfo->auth_pwfile_type == AUTHFILETYPE_DBM) {
!  	DBM* db;
!  	datum dtKey, dtRec;
! 
! 	if(!(db = DBM_Open(reqInfo->auth_pwfile,O_RDONLY, 0))) {
! 	    sprintf(errstr,"Could not open user file %s",reqInfo->auth_pwfile);
! 	    die(reqInfo,SC_SERVER_ERROR,errstr);
   	}
- 	dtKey.dptr = user;
-  	dtKey.dsize = strlen(user);
-  	dtRec = dbm_fetch(db, dtKey);
-  	DBM_Close(db);
-  	if (dtRec.dptr) {
-   	    strncpy(pw, dtRec.dptr, dtRec.dsize);
-             pw[dtRec.dsize] = '\0';
- 	    return 1; 	
- 	}
-  	else
- 	    return 0; 
-     } 
  #endif /* DBM_SUPPORT */
  #ifdef NIS_SUPPORT
      else if (reqInfo->auth_pwfile_type == AUTHFILETYPE_NIS) {
!       char    *domain,
!               *pwfile,
!               *resptr;
!       int     yperr,
!               resize;
! 
!       if (init_nis(&domain) != 0)
!               return 0;
! 
!       if (strcmp(reqInfo->auth_pwfile, "+"))
!               pwfile = reqInfo->auth_pwfile;
!       else
!               pwfile = "passwd.byname";
! 
!       yperr = yp_match(domain, pwfile, user, strlen(user), &resptr, &resize);
!       if (yperr == 0) {
!               getword(w, resptr, ':');
!               if (strcmp(w, user) == 0) {
!                       getword(w, resptr, ':');
!                       (void) strcpy(pw, w);
!                       return 1;
                }
-       }
-       return 0;
-     } 
  #endif /* NIS_SUPPORT */
      else
  	die(reqInfo,SC_SERVER_ERROR,"Invalid password file type"); 
--- 122,134 ----
      } 
  #ifdef DBM_SUPPORT
      else if(reqInfo->auth_pwfile_type == AUTHFILETYPE_DBM) {
!       return dbm_get_pw(reqInfo,user,pw);
      } 
  #endif /* DBM_SUPPORT */
  #ifdef NIS_SUPPORT
      else if (reqInfo->auth_pwfile_type == AUTHFILETYPE_NIS) {
!       return nis_get_pw(reqInfo,user,pw);
      } 
  #endif /* NIS_SUPPORT */
      else
  	die(reqInfo,SC_SERVER_ERROR,"Invalid password file type"); 
***************
*** 275,319 ****
     return Found;
  }
  
! /* nis_group_lookup()
!  *   Validate a user in an NIS group.  Retrieves the group from an NIS database.
!  *   (Default group file is webgroup)
!  *   return 0 on failure, 1 on success 
!  */
! #ifdef NIS_SUPPORT
! int nis_group_lookup(per_request *reqInfo, char *user, char *group)
  {
!       char    *domain,
!               *grfile,
!               *resptr,
!               w[MAX_STRING_LEN];
!       int     yperr,
!               resize;
   
!       if (init_nis(&domain) != 0) {
!         log_error("HTTPd/NIS: init_nis() failed",reqInfo->hostInfo->error_log); 
!         return 0;
        }
!  
!       if (strcmp(reqInfo->auth_grpfile, "+"))
!               grfile = reqInfo->auth_grpfile;
        else
-               grfile = "webgroup";
-  
-       yperr = yp_match(domain, grfile, group, strlen(group), &resptr, &resize);
-       if (yperr != 0) {
- 	sprintf(w,"HTTPd/NIS: yp_match() failed, yperr = %d\n",yperr);
- 	log_error(w,reqInfo->hostInfo->error_log);
          return 0;
-       }
-  
-       getword(w, resptr, ':');
-       if (strcmp(w, group) != 0)
-               return 0;
-  
-       return in_list(user,resptr);
  }
- #endif /* NIS_SUPPORT */
  
  /* dbm_group_lookup()
   * Implicitly requires group line not to exceed HUGE_STRING_LEN because
--- 190,218 ----
     return Found;
  }
  
! #ifdef DBM_SUPPORT
! int dbm_get_pw(per_request *reqInfo, char *user, char *pw) 
  {
!   DBM* db;
!   datum dtKey, dtRec;
!   char errstr[MAX_STRING_LEN];
    
!   if(!(db = DBM_Open(reqInfo->auth_pwfile,O_RDONLY, 0))) {
!     sprintf(errstr,"Could not open user file %s",reqInfo->auth_pwfile);
!     die(reqInfo,SC_SERVER_ERROR,errstr);
    }
!   dtKey.dptr = user;
!   dtKey.dsize = strlen(user);
!   dtRec = dbm_fetch(db, dtKey);
!   DBM_Close(db);
!   if (dtRec.dptr) {
!     strncpy(pw, dtRec.dptr, dtRec.dsize);
!     pw[dtRec.dsize] = '\0';
!     return 1; 	
!   }
    else
      return 0; 
  }
  
  /* dbm_group_lookup()
   * Implicitly requires group line not to exceed HUGE_STRING_LEN because
***************
*** 321,327 ****
   * Searches open DBM database (db) for keypair with the group name as key
   * and returns 0 if user or group not found, 1 if user is in group
   */
- #ifdef DBM_SUPPORT
  int dbm_group_lookup(per_request *reqInfo, char *user, char *group, DBM *db)
  {
    datum dtKey, dtRec;
--- 220,225 ----
***************
*** 337,355 ****
  }
  #endif /* DBM_SUPPORT */
  
! int in_group(per_request *reqInfo, char *user, 
! 	     char *group, char* gfile_mem 
  #ifdef DBM_SUPPORT
  	     , DBM* db 
  #endif /* DBM_SUPPORT */
  ) 
  {
-   char *cur_group = NULL;
-   char *cur_list = NULL;
    int  bFound = FALSE;
    int Done = FALSE;
  
    if (reqInfo->auth_grpfile_type == AUTHFILETYPE_STANDARD) {
      cur_group = strtok(gfile_mem,":");
      while (!Done && !bFound) {
        cur_list = strtok(NULL,"\n");
--- 235,275 ----
  }
  #endif /* DBM_SUPPORT */
  
! int mind(char *S, char *possible)
! {
!   int x,y;
!   for (x = 0; S[x]; x++)
!     for (y = 0; possible[y]; y++) 
!       if (S[x] == possible[y]) return x;
!   return -1;
! }
! 
! int eoln(char *S)
! {
!   int x;
!   for (x = 0; S[x]; x++)
!     if (S[x] == '\n') return x;
!   return x;
! }
! 
! int in_group(per_request *reqInfo, char *user, char *group, char* gfile_mem 
  #ifdef DBM_SUPPORT
  	     , DBM* db 
  #endif /* DBM_SUPPORT */
  ) 
  {
    int  bFound = FALSE;
    int Done = FALSE;
  
+ /* Currently broken because it mods the current group file in memory,
+  * so you can only allow access by one group
+  */
+ 
    if (reqInfo->auth_grpfile_type == AUTHFILETYPE_STANDARD) {
+ /*
+     char *cur_group = NULL;
+     char *cur_list = NULL;
+ 
      cur_group = strtok(gfile_mem,":");
      while (!Done && !bFound) {
        cur_list = strtok(NULL,"\n");
***************
*** 359,365 ****
--- 279,314 ----
        cur_group = strtok(NULL,":");
        if (cur_group == NULL) Done = TRUE;
      }
+ */
+     int beg_line = 0;
+     int end_line = 0;
+     int end_grp = 0;
+     int len = strlen(group);
+     while (!Done && !bFound) {
+       end_grp = ind(&gfile_mem[beg_line],':');
+       if (end_grp != -1) {
+         end_line = ind(&gfile_mem[beg_line],'\n');
+ 	if (end_line < 0) {
+ 	  end_line = strlen(&gfile_mem[beg_line]);
+ 	  Done = TRUE;
          }
+         if (end_line > end_grp) {
+ 	  if ((end_grp == len) && 
+ 	      (!strncmp(&gfile_mem[beg_line],group,len)))
+           {
+ 	    bFound = in_listn(user,&gfile_mem[beg_line+end_grp+1],end_line - end_grp);
+ /*	    fprintf(stderr,"User: %s\tGroup: %s\n",user,group);
+ 	    fputsn(stderr, */
+           }
+         } else {
+ 	/* hmm, how to handle the backward compat with the bug in 1.5 which
+ 	 * allowed a group to span multiple lines
+ 	 */
+         }
+         beg_line += end_line+1;
+       } else Done = TRUE;
+     }
+   }
  #ifdef DBM_SUPPORT
    else if (reqInfo->auth_grpfile_type == AUTHFILETYPE_DBM) {
      bFound = dbm_group_lookup(reqInfo,user,group,db);
***************
*** 452,457 ****
--- 401,412 ----
          die(reqInfo,SC_AUTH_REQUIRED,errstr);
      }
  #endif /* KRB5 */
+ #ifdef SHTTP
+     if(!strncasecmp(auth_type,"SHTTP",5)) {
+ 	sprintf(errstr,"%s [SHTTP]",s);
+ 	die(reqInfo,SC_AUTH_NO_WWW_AUTH,errstr);
+     }
+ #endif /* SHTTP */
      else {
          sprintf(errstr,"Unknown authorization method %s",auth_type);
          die(reqInfo,SC_SERVER_ERROR,errstr);
***************
*** 485,491 ****
--- 440,474 ----
      if(!sec->auth_type[0])
  	strcpy(sec->auth_type, "Basic");
      
+ #ifdef SHTTP
+    /* S-HTTP message may not have Authorization line, but
+     * we still need to check for required S-HTTP enhancements ADC ZZZZ 
+     */
  
+     if (!strncasecmp(sec->auth_type,"SHTTP",5)) { 
+       list_el *tmp;
+       char *err = "Must use SHTTP protocol for this URL";
+ 
+       if (!(reqInfo->RequestFlags & DOING_SHTTP))
+ 	auth_bong(reqInfo,err,reqInfo->auth_name, sec->auth_type);
+ 
+       /* Now do our SHTTP checks... These don't fit into McCool's
+        * framework, so we'll do it ourselves
+        */
+       tmp=TSW_ll_first(sec->shttp_auth_lines);
+ 
+       if (!tmp)  /* in case we Require SHTTP, but no SHTTPAuthAccept lines */
+ 	return;
+ 
+       while(tmp){
+         if(!(err=shttp_check_auth(reqInfo,(char *)TSW_ll_data(tmp))))
+           return;
+         tmp=TSW_ll_next(tmp);
+       }
+       auth_bong(reqInfo,err,reqInfo->auth_name,sec->auth_type);
+     }
+ #endif /* SHTTP */
+ 
      /* No authorization info, so return the 401 to retrieve it */
      if(!auth_line[0])
  	   auth_bong(reqInfo,NULL, reqInfo->auth_name, sec->auth_type);
***************
*** 512,518 ****
              die(reqInfo,SC_SERVER_ERROR,errstr);
          }
  
!         uudecode(auth_line + strlen(auth_type),(unsigned char *)ad,MAX_STRING_LEN);
          getword(reqInfo->auth_user,ad,':');
          strcpy(sent_pw,ad);
          if(!get_pw(reqInfo,reqInfo->auth_user,real_pw,sec)) {
--- 495,502 ----
              die(reqInfo,SC_SERVER_ERROR,errstr);
          }
  
!         uudecode(auth_line + strlen(auth_type),(unsigned char *)ad,
! 		 MAX_STRING_LEN);
          getword(reqInfo->auth_user,ad,':');
          strcpy(sent_pw,ad);
          if(!get_pw(reqInfo,reqInfo->auth_user,real_pw,sec)) {
***************
*** 569,577 ****
      
  	if (krbresult) {
  	    if (check_krb_restrict(reqInfo, sec, &kdat)) {
! 		remote_logname = user;
  		sprintf(reqInfo->outh_www_auth,"%s %s", 
  			sec->auth_type, krb_authreply);
  		return;
  	    }
  	    else {
--- 553,566 ----
      
  	if (krbresult) {
  	    if (check_krb_restrict(reqInfo, sec, &kdat)) {
! 		remote_logname = reqInfo->auth_user;
  		sprintf(reqInfo->outh_www_auth,"%s %s", 
  			sec->auth_type, krb_authreply);
+ 		/* we must set status line so that it is not considered
+ 		   a 401 by send_http_headers
+ 		*/
+ 		set_stat_line(reqInfo);
+ 
  		return;
  	    }
  	    else {
***************
*** 588,593 ****
--- 577,599 ----
  	}
      }
  #endif /* HAVE_KERBEROS */
+ #ifdef SHTTP
+  /* I don't think SHTTP would ever get this far . . . */
+     else if (!strncasecmp(sec->auth_type, "SHTTP",5)) {
+       list_el *tmp;
+       char *err; 
+    
+       /* Now do our SHTTP checks... These don't fit into McCool's
+        * framework, so we'll do it ourselves*/
+       tmp=TSW_ll_first(sec->shttp_auth_lines);
+       while(tmp){
+         if(!(err=shttp_check_auth(reqInfo,(char *)TSW_ll_data(tmp))))
+           return;
+         tmp=TSW_ll_next(tmp);
+       }
+       auth_bong(reqInfo,err,reqInfo->auth_name,sec->auth_type);
+     }
+ #endif /* SHTTP */
      else {
          sprintf(errstr,"unknown authorization type %s for %s",sec->auth_type,
                  sec->d);
***************
*** 609,623 ****
--- 615,634 ----
  #endif /* DBM_SUPPORT */
      }
  
+ /* Check require lines */
      bValid = 0;
      for(x=0;x<sec->num_auth[reqInfo->method] && !bValid;x++) {
          strcpy(t,sec->auth[reqInfo->method][x]);
          getword(w,t,' ');
          if(!strcmp(w,"valid-user")) {
+ 	  /* We've already done a user lookup (successful), so if all that's
+ 	   * required is a valid user, return valid
+ 	   */
  	    bValid = 1;
          } 
          else if(!strcmp(w,"user")) {
              while(t[0]) {
+ 	      /* Remove quotes?  must be for backward compatibility? */
                  if(t[0] == '\"') {
                      getword(w,&t[1],'\"');
                      for(y=0;t[y];y++)
***************
*** 669,1051 ****
      }
  }
  
- #ifdef HAVE_KERBEROS
- 
- /*************************************************************************
-  * kdata_to_str -- convert 8-bit char array to ascii string
-  *
-  * Accepts:  input array and length
-  * Returns:  a pointer to the result, or null pointer on malloc failure
-  *           The caller is responsible for freeing the returned value.
-  *
-  * Changed to accomodate general strings with length, due to conflict between
-  *    KTEXT and krb5_data types  ( 6/28/95 ADC)
-  ************************************************************************/
- static char *kdata_to_str(in_data, length)
-     char *in_data;                      /* char FAR ?? */
-     int length;
- {
-     char *result, *p;
-     int i;
- 
-     p = result = malloc(length*2+1);
-     if (!result) return (char *) NULL;
- 
-     for (i=0; i < length; i++) {
-         *p++ = hex[(in_data[i]>>4)&0xf];
-         *p++ = hex[(in_data[i])&0xf];
-     }
-     *p++ = '\0';
-     return result;
- }
- 
- 
- /*************************************************************************
-  * str_to_kdata -- Converts ascii string to a (binary) char array
-  *
-  * Accepts: string to convert
-  *          pointer to output array
-  * Returns: length of output array, NIL on failure
-  ************************************************************************/
- int str_to_kdata(in_str, out_str)
-     char *in_str;
-     char *out_str;
- {
-     int inlen, outlen;
- 
-     inlen = strlen(in_str);
-     if (inlen & 1) return NIL;  /* must be even number, in this scheme */
-     inlen /= 2;
-     if (inlen > MAX_KDATA_LEN) return NIL;
- 
-     for (outlen=0; *in_str; outlen++, in_str += 2) {
-         out_str[outlen] = (dec[in_str[0]]<<4) + dec[in_str[1]];
-     }
-     return outlen;
- }
- 
- /*************************************************************************
-  * kerberos_server_auth -- Kerberos-authenticated server log in
-  * Accepts: user name string
-  *          password string
-  *          pointer to char pointer.  The char pointer is set to the
-  *               text we want returned in the reply message.
-  * Returns: T if login ok, NIL otherwise
-  ************************************************************************/
- #ifdef KRB4
- int k4_server_auth(char* authline, char* reply,FILE* error_log, 
- 		   KerberosInfo *kdat)
- {
-     char pass[HUGE_STRING_LEN];
-     int code;
-     KTEXT_ST authent;
-     char instance[INST_SZ];
-     static AUTH_DAT kdata;
-     char realm[REALM_SZ];
-     char local_realm[REALM_SZ];
-     char *p;
-     
-     getword(user, authline, ' ');
-     getword(pass, authline, '\0');
-     
- 
-     /* Convert pass to authent */
-     if ((authent.length = str_to_kdata(pass, authent.dat)) == NIL) {
- 	strcpy(reply,"Invalid Kerberos authenticator");
- 	return NIL;
-     }
-  
-     /* Verify authenticator */
-     strcpy(instance, "*");	/* is this ok? */
-     if (k4_srvtab[0]) {
-         code = krb_rd_req(&authent, "khttp", instance, 0L, &kdata, k4_srvtab);
-     }
-     else {
-         code = krb_rd_req(&authent, "khttp", instance, 0L, &kdata, NULL);
-     }
- 
-     if (code) {
- 	sprintf(reply, krb_err_txt[code]);
- 	log_error(reply,error_log);
- 	return NIL;
-     }
- 
-     /* Check authorization of the Kerberos user */
-     if (strncmp(kdata.pname, user, ANAME_SZ)) {
- 	strcpy(reply, "Permission denied; name/username mismatch.");
- 	return NIL;
-     }
- 
-     if (code = krb_get_lrealm(local_realm, 1)) {
- 	sprintf(reply, krb_err_txt[code]);
- 	log_error(reply, error_log);
- 	return NIL;
-     }
- 
-     /* to perform further restriction through .htaccess in check_auth */
-     strcpy (kdat->client_name, kdata.pname);
-     strcpy (kdat->client_realm, kdata.prealm);
-     strcpy (kdat->server_realm, local_realm);
-     kdat->ver = KERBEROSV4;
- 
-     /* gacck: compat. with older kerb code */
-     memcpy(&kerb_kdata, &kdata, sizeof(kdata));
- 
-     /* Save the session key */
-     bcopy(kdata.session, session, sizeof(des_cblock));
-     key_sched(session, schedule);
-    
-     /* Construct the response for mutual authentication */
-     authent.length = sizeof(des_cblock);
-     bzero(authent.dat, sizeof(des_cblock));
-     *((long *)authent.dat) = htonl(kdata.checksum + 1);
-     des_ecb_encrypt(authent.dat, authent.dat, schedule, 1);
- 
-     /* Convert response to string and place in buffer */
-     p = kdata_to_str(&authent.dat, authent.length);
- 
-     if (p) {
- 	*reply = '[';
- 	strcpy(reply+1, p);
- 	strcat(reply, "] User ");
- 	strcat(reply, user);
- 	strcat(reply, " authenticated");
- 	free(p);
-     }
-     else {
- 	/* XXX Out of memory */
- 	exit(1);
-     }
- 
-     strncpy(user, user, MAX_STRING_LEN - 1);
-     return T;
- }
- #endif	/* KRB4 */
- /**********************************************************************/
- #ifdef KRB5
- int k5_server_auth(char* authline, char* reply, KerberosInfo *kdat)
- {
-     char pass[HUGE_STRING_LEN];
-     char tmpstr[MAX_KDATA_LEN];
-     char *p;
- 
-     krb5_context k5context;
-     krb5_auth_context *k5auth_context = NULL;
-     krb5_principal serverp, clientp;
-     krb5_data k5authent;
-     krb5_ticket *k5ticket = NULL;
-     krb5_error_code code;
-     krb5_keytab k5keytabid = NULL;
-     krb5_data k5ap_rep_data;
- 
- 
-     getword(user, authline, ' ');
-     getword(pass, authline, '\0');
- 
-     /* Convert pass to authent */
-     if ((k5authent.length = str_to_kdata(pass, tmpstr)) == NIL) {
-         sprintf(reply, "Invalid authenticator");
-         return NIL;
-     }
-     k5authent.data = tmpstr;
- 
-     code = krb5_init_context(&k5context);
-     if (code) {
-         sprintf(reply, "krb5_init_context error: %s",error_message(code));
- 	return NIL;
-     }
- 
-     krb5_init_ets(k5context);
- 
-     /* find server principal name; NULL means krb libs determine my hostname */
- 
-     code = krb5_sname_to_principal(k5context, NULL, "khttp", KRB5_NT_SRV_HST,
- 				   &serverp);
-     if (code) {
-         sprintf(reply, "Error finding server Krb5 principal name: %s",error_message(code));
- 	return NIL;
-     }
- 
-     /* perhaps get client address?  (using getpeername)  */
- 
- 
-     /* Check for user-specified keytab */
- 
-     if (k5_srvtab[0]) {
- 	code = krb5_kt_resolve(k5context, k5_srvtab, &k5keytabid);
- 	if (code) {
-             sprintf(reply, "Error resolving keytab file: %s",error_message(code));
- 	    return NIL;
- 	}
-     }
- 
-     /* and most importantly, check the client's authenticator   */
- 
-     code = krb5_rd_req(k5context, &k5auth_context, &k5authent,
- 		       serverp, k5keytabid, NULL, &k5ticket);
-     if (code) {
- 	sprintf(reply, "krb5_rd_req error: %s",error_message(code));
-         return NIL;
-     }
- 
-     clientp = k5ticket->enc_part2->client;
-    
-     /* to perform further restriction through .htaccess in check_auth */
- 
-     strncpy (kdat->client_name, clientp->data->data,clientp->data->length);
-     strcpy (kdat->client_realm, clientp->realm.data);
-     strcpy (kdat->server_realm, serverp->realm.data);
-     kdat->ver = KERBEROSV5;
- 
-     /* make sure client username matches username submitted in Auth line */
- 
-     /* removed for now; redundant and possibly buggy   ADC
-     if (strncmp(kdat->client_name, user, MAX_STRING_LEN)) {
- 	strcpy(reply, "Permission denied; name/username mismatch."); 
-         return NIL;
-     }
-     */
-     /* send an AP_REP message to complete mutual authentication */
- 
-     code = krb5_mk_rep(k5context, k5auth_context, &k5ap_rep_data);
- 
-     if (code) {
-         sprintf(reply, "krb5_mk_rep error: %s",error_message(code));
-         return NIL;
-     }
- 
-     /* Convert response to string and place in buffer */
-     p = kdata_to_str(k5ap_rep_data.data, k5ap_rep_data.length);
- 
-     if (p) {
-         *reply = '[';
-         strcpy(reply+1, p);
-         strcat(reply, "] User ");
-         strcat(reply, user);
-         strcat(reply, " authenticated");
-         free(p);
-     }
-     else {
-         /* XXX Out of memory */
-         exit(1);
-     }
- 
- /* call any krb5_free routines??  perhaps krb_free_ticked(k5ticket) ? */
- 
-     strncpy(user, user, MAX_STRING_LEN - 1);
-     return T;
- }
- #endif   /* KRB5 */
- 
- int check_krb_restrict(per_request* reqInfo, security_data* sec, KerberosInfo* kdat)
- {
-     int grpstatus;
-     char* pchGrpData = NULL;
-     int ndx;
-     int bValid;
-     char line[MAX_STRING_LEN];
-     char errstr[MAX_STRING_LEN];
-     char* realm;
-     char* tok;
-     
-     /* Common stuff: Check for valid user */
-     grpstatus = 0;
-     if(reqInfo->auth_grpfile) {
- 	if (pchGrpData = init_group(reqInfo,reqInfo->auth_grpfile))
- 	    grpstatus = 1;
-     }
- 
-     bValid = 0;
-     for(ndx=0;ndx<sec->num_auth[reqInfo->method] && !bValid;ndx++) {
-         strcpy(line,sec->auth[reqInfo->method][ndx]);
- 	tok = strtok (line, " \t");
-         if(!strcmp(tok,"valid-user")) 
- 	    bValid = 1;
-         else if(!strcmp(tok,"user")) {
-             while(tok = strtok (NULL, " \t")) {
- 		if (realm = strchr (tok, '@'))
- 		    *realm++ = '\0';
- 
-                 if(!strcmp(kdat->client_name,tok)) {
- 		    if (!realm  && 
- 			!strcasecmp(kdat->server_realm, kdat->client_realm)) {
- 			bValid = 1;
- 			break;
- 		    }
- 		    else if (realm && !strcasecmp(realm, kdat->client_realm)) {
- 			bValid = 1;
- 			break;
- 		    }
- 		}
- 	    }
- 	}
- 	else if(!strcmp(tok,"realm")) {
-             while(tok = strtok (NULL, " \t")) {
-                 if(!strcasecmp(kdat->client_realm,tok)) {
- 		    bValid = 1;
- 		    break;
- 		}
-             }
-         }
-         else if(!strcmp(tok,"group")) {
-             if(!grpstatus) {
-                 sprintf(errstr,"group required for %s, bad groupfile",
-                         sec->d);
-                 auth_bong(reqInfo,errstr,reqInfo->auth_name,sec->auth_type);
-             }
-             while(tok = strtok (NULL, " \t")) {
-                 if (krb_in_group(kdat, tok, pchGrpData)) {
- 		    strcpy(groupname,tok);
- 		    bValid = 1;
- 		    break;
- 		}
-             }
-         }
-         else
-             auth_bong(reqInfo,"require not followed by user or group",
- 		      reqInfo->auth_name,sec->auth_type);
-     }
- 
-     if(grpstatus)
- 	free (pchGrpData);
- 
-     return bValid;
- }
- 
- int krb_in_group(KerberosInfo* kdat, char *group, char* pchGrps)
- {
-     char *mems, *endp = NULL;
-     char *pch;
-     char chSaved;
-     int  nlen, bFound = 0;
- 
-     nlen = strlen (group);
-     if ((mems = strstr (pchGrps, group)) && *(mems + nlen) == ':') {
- 	if (endp = strchr (mems + nlen + 1, ':')) {
- 	    while (!isspace(*endp)) endp--;
- 	    chSaved = *endp;
- 	    *endp = '\0';
- 	}
-     }
-     else
- 	return 0;
- 
-     nlen = strlen (kdat->client_name);
-     if(pch = strstr(mems, kdat->client_name)) {
- 	pch += nlen;
- 	if (!*pch || isspace(*pch) && 
- 	    !strcasecmp(kdat->client_realm, kdat->server_realm)) 
- 	    bFound = 1;
- 	else if (*pch == '@') {
- 	    pch++;
- 	    nlen = strlen (kdat->client_realm);
- 	    if (!strncmp (kdat->client_realm, pch, nlen))
- 		bFound = 1;
- 	}
-     }
- 
-     if (endp && *endp == '\0') *endp = chSaved;
-     return bFound;
- }
- 
- #endif   /* HAVE_KERBEROS */
--- 680,682 ----
diff -brc ./http_auth.h /X11/blong/httpd/src//http_auth.h
*** ./http_auth.h	Tue Jun 25 17:06:15 1996
--- /X11/blong/httpd/src//http_auth.h	Wed Jun 12 17:51:29 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_auth.h,v 1.22 1996/03/27 20:43:57 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_auth.h,v 1.26 1996/06/12 22:51:29 blong Exp $
   *
   ************************************************************************
   *
***************
*** 25,42 ****
  #  include <ndbm.h>
  # endif /* _DBMSUPPORT_H */
  #endif /* DBM_SUPPORT */
- #include "global.h"
  
  /* globals defined in this module */
  
- 
- 
- /* http_auth */
  void check_auth(per_request *reqInfo, security_data *s, char* auth_line);
  int get_pw(per_request *reqInfo, char *user, char *pw, security_data* sec);
  #ifdef DBM_SUPPORT
  int in_group(per_request *reqInfo, char *user, char *group, char* pchGrps, 
  	     DBM* db);
  #else
  int in_group(per_request *reqInfo, char *user, char *group, char* pchGrps);
  #endif /* DBM_SUPPORT */
--- 25,39 ----
  #  include <ndbm.h>
  # endif /* _DBMSUPPORT_H */
  #endif /* DBM_SUPPORT */
  
  /* globals defined in this module */
  
  void check_auth(per_request *reqInfo, security_data *s, char* auth_line);
  int get_pw(per_request *reqInfo, char *user, char *pw, security_data* sec);
  #ifdef DBM_SUPPORT
  int in_group(per_request *reqInfo, char *user, char *group, char* pchGrps, 
  	     DBM* db);
+ int dbm_get_pw(per_request *reqInfo, char *user, char *pw);
  #else
  int in_group(per_request *reqInfo, char *user, char *group, char* pchGrps);
  #endif /* DBM_SUPPORT */
***************
*** 43,72 ****
  char* init_group(per_request *reqInfo,char* grpfile);
  void auth_bong(per_request *reqInfo,char *s,char* auth_name, char* auth_type);
  
! #if defined(KRB4) || defined(KRB5)
! typedef struct _krbdata {
!     char client_name[MAX_STRING_LEN];
!     char client_realm[MAX_STRING_LEN];
!     char server_realm[MAX_STRING_LEN];
!     int  ver;
! } KerberosInfo;
! 
! #define KERBEROSV4 0
! #define KERBEROSV5 1
! 
! int check_krb_restrict(per_request* reqInfo, security_data* sec, KerberosInfo* kdat);
! int krb_in_group(KerberosInfo* kdat, char *group, char* pchGrps);
! #endif /* KRB4 or KRB5 */
! 
! #ifdef KRB4
! extern char k4_srvtab[];
! int k4_server_auth(char* authline, char* reply,FILE* error_log, 
! 		   KerberosInfo *kdat);
! #endif	/* KRB4 */
! 
! #ifdef KRB5
! extern char k5_srvtab[];
! int k5_server_auth(char* authline, char* reply, KerberosInfo *kdat);
! #endif /* KRB5 */
! 
  #endif /* _HTTP_AUTH_H_ */
--- 40,45 ----
  char* init_group(per_request *reqInfo,char* grpfile);
  void auth_bong(per_request *reqInfo,char *s,char* auth_name, char* auth_type);
  
! int in_list(char *user, char *list);
! int in_listn(char *user, char *list, int len);
  #endif /* _HTTP_AUTH_H_ */
Only in /X11/blong/httpd/src/: http_auth.o
diff -brc ./http_config.c /X11/blong/httpd/src//http_config.c
*** ./http_config.c	Tue Jun 25 17:06:15 1996
--- /X11/blong/httpd/src//http_config.c	Wed Jun 12 16:11:52 1996
***************
*** 31,41 ****
--- 31,48 ----
  # endif /* NEED_SYS_MALLOC_H */
  #endif /* NO_MALLOC_H */
  #include <string.h>
+ #include <setjmp.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <sys/socket.h>
+ #include <netinet/in.h>
+ #include <arpa/inet.h>
  #include <netdb.h>
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "fdwrap.h"
  #include "http_config.h"
  #include "host_config.h"
***************
*** 45,52 ****
  #include "http_log.h"
  #include "http_dir.h"
  #include "util.h"
! #include <netinet/in.h>
! #include <arpa/inet.h>
  
  
  /* Server config globals */
--- 52,63 ----
  #include "http_log.h"
  #include "http_dir.h"
  #include "util.h"
! #ifdef FCGI_SUPPORT
! # include "fcgi.h"	/* for AppClassCmd() */
! #endif /* FCGI_SUPPORT */
! #ifdef SSL_SUPPORT
! # include "http_ssl.h"
! #endif /* SSL_SUPPORT */
  
  
  /* Server config globals */
***************
*** 69,74 ****
--- 80,92 ----
  char local_default_icon[MAX_STRING_LEN];
  int  log_directory_group_write_ok = 0;
  int  log_directory_other_write_ok = 0;
+ #ifdef LOG_TIMES 
+ unsigned long clk_ticks;
+ #endif /* LOG_TIMES */
+ #ifdef SHTTP
+ char *shttp_server_dns = NULL;
+ char *shttp_cert_db = NULL;
+ #endif /* SHTTP */
  
  /* Access Globals*/
  int num_sec;
***************
*** 103,108 ****
--- 121,131 ----
    char tmp[MAX_STRING_LEN];
  
    standalone = 1;
+ #ifdef SSL_SUPPORT
+   if (ssl_enabled == TRUE)
+     port = DEFAULT_SSL_PORT;
+    else
+ #endif /* SSL_SUPPORT */
    port = DEFAULT_PORT;
    user_id = uname2id(DEFAULT_USER);
    group_id = gname2id(DEFAULT_GROUP);
***************
*** 224,229 ****
--- 247,266 ----
  	cfg_getword(w,l);
  	port = atoi(w);
        }
+ #ifdef SSL_SUPPORT
+       else if(!strcasecmp(w,"SSLPort") && !virtual) {
+ 	cfg_getword(w,l);
+ 	if (ssl_enabled) port = atoi(w);
+       }
+       else if(!strcasecmp(w,"SSLeayCert") && !virtual) {
+ 	cfg_getword(w,l);
+ 	if (ssl_enabled) my_ssl_cert_file = strdup(w);
+       }
+       else if(!strcasecmp(w,"SSLeayKey") && !virtual) {
+ 	cfg_getword(w,l);
+ 	if (ssl_enabled) my_ssl_key_file = strdup(w);
+       }
+ #endif /* SSL_SUPPORT */
        else if(!strcasecmp(w,"BindAddress") && !virtual) {
  	struct hostent *hep;
  	unsigned long ina;
***************
*** 355,369 ****
  	  if (!strcasecmp(w,"Combined")) {
  	    set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
  	    host->log_opts |= LOG_COMBINED;
!           } else if (!strcasecmp(w,"Separate")) {
  	    set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
  	    host->log_opts &= LOG_SEPARATE;
!           } else if (!strcasecmp(w,"ServerName")) {
              set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
              host->log_opts |= LOG_SERVERNAME;
! 	  } else if (!strcasecmp(w,"Date")) {
  	    set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
  	    host->log_opts |= LOG_DATE;
  	  } else {
  	    config_error("Valid LogOptions are Combined or Separate, ServerName",
  			  server_confname,n,errors);	
--- 392,427 ----
  	  if (!strcasecmp(w,"Combined")) {
  	    set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
  	    host->log_opts |= LOG_COMBINED;
!           } 
!           else if (!strcasecmp(w,"Separate")) {
  	    set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
  	    host->log_opts &= LOG_SEPARATE;
!           } 
! 	  else if (!strcasecmp(w,"ServerName")) {
              set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
              host->log_opts |= LOG_SERVERNAME;
! 	  } 
! 	  else if (!strcasecmp(w,"Date")) {
  	    set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
  	    host->log_opts |= LOG_DATE;
+          }
+ #ifdef LOG_TIMES
+          else if (!strcasecmp(w,"RealTime")) {
+            set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
+            host->log_opts |= LOG_REALTIME;
+          } 
+ 	 else if (!strcasecmp(w,"CPUTime")) {
+            set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
+            host->log_opts |= LOG_CPUTIME;
+          } 
+ #endif /* LOG_TIMES */
+ 	 else if (!strcasecmp(w,"Referer")) {
+            set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
+            host->log_opts |= LOG_REFERER;
+          } 
+ 	 else if (!strcasecmp(w,"UserAgent")) {
+            set_host_conf_value(host,PH_HTTPD_CONF,HC_LOG_TYPE);
+            host->log_opts |= LOG_USERAGENT;
           } else {
  	    config_error("Valid LogOptions are Combined or Separate, ServerName",
  			  server_confname,n,errors);	
***************
*** 456,461 ****
--- 514,527 ----
         */
        }
  #endif /* DIGEST_AUTH */
+ #ifdef SHTTP
+       else if(!strcasecmp(w,"SHTTPDistinguishedNamedb")) {
+ 	shttp_server_dns = strdup(TSW_trimbuf(l));
+       }
+       else if(!strcasecmp(w,"SHTTPCertdb")) {
+ 	shttp_cert_db = strdup(TSW_trimbuf(l));
+       }
+ #endif /* SHTTP */
        else if(((!strcasecmp(w,"<VirtualHost")) || (!strcasecmp(w,"<Host")))
  	      && !virtual) {
  	struct hostent *hep;
***************
*** 576,582 ****
          if (result)
            config_error(result, host->srm_confname, n, errors);
        }
! #endif /* FCGI */
        else if(!strcasecmp(w,"UserDir")) {
  	cfg_getword(w,l);
  	if(!strcmp(w,"DISABLED"))
--- 642,649 ----
          if (result)
            config_error(result, host->srm_confname, n, errors);
        }
! #endif /* FCGI_SUPPORT */
! 
        else if(!strcasecmp(w,"UserDir")) {
  	cfg_getword(w,l);
  	if(!strcmp(w,"DISABLED"))
***************
*** 842,847 ****
--- 909,918 ----
  #ifdef DIGEST_AUTH
      sec[x].auth_digestfile[0] = '\0';
  #endif /* DIGEST_AUTH */
+ #ifdef SHTTP
+     sec[x].shttp_auth_lines = NULL;
+     sec[x].shttp_privacy_enhancements = NULL;
+ #endif /* SHTTP */
      sec[x].auth_grpfile[0] = '\0';
      for(i=0;i<METHODS;i++) {
          sec[x].order[i] = DENY_THEN_ALLOW;
***************
*** 876,881 ****
--- 947,956 ----
                      sec[x].override |= OR_INDEXES;
  		else if(!strcasecmp(w,"Redirect"))
  		    sec[x].override |= OR_REDIRECT;
+ #ifdef SHTTP
+ 		else if(!strcasecmp(w,"PrivEnhance"))
+ 		    sec[x].override |= OR_PRIVACY_ENHANCE;
+ #endif /* SHTTP */
                  else if(!strcasecmp(w,"None"))
                      sec[x].override = OR_NONE;
                  else if(!strcasecmp(w,"All")) 
***************
*** 981,986 ****
--- 1056,1083 ----
  #endif /* NIS_SUPPORT */
  		sec[x].auth_grpfile_type = AUTHFILETYPE_STANDARD;
          }
+ #ifdef SHTTP
+         else if(!strcasecmp(w,"SHTTPAuthAccept")){
+ #ifdef SHTTP_DEBUG
+ 	fprintf(stderr,"Request SHTTPAuthAccept in .htacces: %s\n",l);
+ 	fflush(stderr);
+ #endif /* SHTTP_DEBUG */
+           if(!(or & OR_AUTHCFG))
+             access_syntax_error(reqInfo,n,"override violation",f,file);
+           TSW_ll_insert(&(sec[x].shttp_auth_lines),(void *)strdup(l));
+         }
+         else if(!strcasecmp(w,"SHTTPPrivacyEnhancements")){
+ 
+ #ifdef SHTTP_DEBUG
+ 	fprintf(stderr,"Response SHTTPPrivacyEnhancements in .htacces: %s\n",l);
+ 	fflush(stderr);
+ #endif /* SHTTP_DEBUG */
+ 
+         if(!(or & OR_PRIVACY_ENHANCE))
+             access_syntax_error(reqInfo,n,"override violation",f,file);
+           sec[x].shttp_privacy_enhancements=strdup(l);
+         }
+ #endif /* SHTTP */
          else if(!strcasecmp(w,"AddType")) {
              if(!(or & OR_FILEINFO))
                  access_syntax_error(reqInfo,n,"override violation",f,file);
diff -brc ./http_config.h /X11/blong/httpd/src//http_config.h
*** ./http_config.h	Tue Jun 25 17:06:15 1996
--- /X11/blong/httpd/src//http_config.h	Wed Jun  5 21:44:35 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_config.h,v 1.15 1996/03/27 20:44:01 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_config.h,v 1.16 1996/06/06 02:44:35 blong Exp $
   *
   ************************************************************************
   *
***************
*** 47,52 ****
--- 47,56 ----
  extern char local_default_icon[];
  extern int  log_directory_group_write_ok;
  extern int  log_directory_other_write_ok;
+ #ifdef LOG_TIMES
+ extern unsigned long clk_ticks;
+ #endif /* LOG_TIMES */
+ 
  
  #ifndef NO_PASS
  extern int max_servers;
Only in /X11/blong/httpd/src/: http_config.o
diff -brc ./http_dir.c /X11/blong/httpd/src//http_dir.c
*** ./http_dir.c	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_dir.c	Fri Jun 21 16:37:37 1996
***************
*** 79,90 ****
      struct item *q;
  
      while(p) {
!         if(p->apply_to) free(p->apply_to);
!         if(p->apply_path) free(p->apply_path);
!         if(p->data) free(p->data);
          q = p;
          p = p->next;
!         free(q);
      }
  }
  
--- 79,90 ----
      struct item *q;
  
      while(p) {
!         if(p->apply_to) Free(p->apply_to);
!         if(p->apply_path) Free(p->apply_path);
!         if(p->data) Free(p->data);
          q = p;
          p = p->next;
!         Free(q);
      }
  }
  
***************
*** 114,120 ****
  		      char *to, char *path, char *data) {
      struct item *p;
  
!     if(!(p = (struct item *)malloc(sizeof(struct item))))
          die(reqInfo,SC_NO_MEMORY,"new_item");
  
      p->type = type;
--- 114,120 ----
  		      char *to, char *path, char *data) {
      struct item *p;
  
!     if(!(p = (struct item *)Malloc(sizeof(struct item))))
          die(reqInfo,SC_NO_MEMORY,"new_item");
  
      p->type = type;
***************
*** 125,131 ****
          p->data = NULL;
  
      if(to) {
!         if(!(p->apply_to = (char *)malloc(strlen(to) + 2)))
              die(reqInfo,SC_NO_MEMORY,"new_item");
          if((type == BY_PATH) && (!is_matchexp(to))) {
              p->apply_to[0] = '*';
--- 125,131 ----
          p->data = NULL;
  
      if(to) {
!         if(!(p->apply_to = (char *)Malloc(strlen(to) + 2)))
              die(reqInfo,SC_NO_MEMORY,"new_item");
          if((type == BY_PATH) && (!is_matchexp(to))) {
              p->apply_to[0] = '*';
***************
*** 135,141 ****
      } else
          p->apply_to = NULL;
  
!     if(!(p->apply_path = (char *)malloc(strlen(path) + 2)))
          die(reqInfo,SC_NO_MEMORY,"new_item");
      sprintf(p->apply_path,"%s*",path);
  
--- 135,141 ----
      } else
          p->apply_to = NULL;
  
!     if(!(p->apply_path = (char *)Malloc(strlen(path) + 2)))
          die(reqInfo,SC_NO_MEMORY,"new_item");
      sprintf(p->apply_path,"%s*",path);
  
***************
*** 443,451 ****
      if(ignore_entry(t))
          return(NULL);
  
!     if(!(p=(struct ent *)malloc(sizeof(struct ent))))
          die(reqInfo,SC_NO_MEMORY,"make_dir_entry");
!     if(!(p->name=(char *)malloc(strlen(name) + 2)))
          die(reqInfo,SC_NO_MEMORY,"make_dir_entry");
  
      if(dir_opts & FANCY_INDEXING) {
--- 443,451 ----
      if(ignore_entry(t))
          return(NULL);
  
!     if(!(p=(struct ent *)Malloc(sizeof(struct ent))))
          die(reqInfo,SC_NO_MEMORY,"make_dir_entry");
!     if(!(p->name=(char *)Malloc(strlen(name) + 2)))
          die(reqInfo,SC_NO_MEMORY,"make_dir_entry");
  
      if(dir_opts & FANCY_INDEXING) {
***************
*** 464,474 ****
              p->alt = NULL;
              p->desc = NULL;
              if(S_ISDIR(finfo.st_mode)) {
!                 if(!(p->icon = find_icon(reqInfo,t,1)))
! 		    if (p->icon != NULL) free(p->icon);
                      p->icon = find_icon(reqInfo,"^^DIRECTORY^^",1);
                  if(!(tmp = find_alt(reqInfo,t,1))){
!                     p->alt = (char *) malloc(sizeof(char)*4);
                      strcpy(p->alt,"DIR");
  		}
  		else {
--- 464,475 ----
              p->alt = NULL;
              p->desc = NULL;
              if(S_ISDIR(finfo.st_mode)) {
!                 if(!(p->icon = find_icon(reqInfo,t,1))) {
! 		    if (p->icon != NULL) Free(p->icon);
                      p->icon = find_icon(reqInfo,"^^DIRECTORY^^",1);
+                 }
                  if(!(tmp = find_alt(reqInfo,t,1))){
!                     p->alt = (char *) Malloc(sizeof(char)*4);
                      strcpy(p->alt,"DIR");
  		}
  		else {
***************
*** 714,720 ****
              num_ent++;
          }
      }
!     if(!(ar=(struct ent **) malloc(num_ent*sizeof(struct ent *)))) {
  	Closedir(d);
          die(reqInfo,SC_NO_MEMORY,"index_directory");
      }
--- 715,721 ----
              num_ent++;
          }
      }
!     if(!(ar=(struct ent **) Malloc(num_ent*sizeof(struct ent *)))) {
  	Closedir(d);
          die(reqInfo,SC_NO_MEMORY,"index_directory");
      }
***************
*** 732,747 ****
            (int (*)(const void *,const void *))dsortf);
  #endif /* ULTRIX_BRAIN_DEATH */
       output_directories(reqInfo,ar,num_ent,reqInfo->url);
!      free(ar);
       q = head;
       while(q) {
           p=q->next;
!          free(q->name);
           if(q->desc)
!              free(q->desc);
  	 if(q->alt)
! 	     free(q->alt);
!          free(q);
           q=p;
       }
       Closedir(d);
--- 733,748 ----
            (int (*)(const void *,const void *))dsortf);
  #endif /* ULTRIX_BRAIN_DEATH */
       output_directories(reqInfo,ar,num_ent,reqInfo->url);
!      Free(ar);
       q = head;
       while(q) {
           p=q->next;
!          Free(q->name);
           if(q->desc)
!              Free(q->desc);
  	 if(q->alt)
! 	     Free(q->alt);
!          Free(q);
           q=p;
       }
       Closedir(d);
diff -brc ./http_dir.h /X11/blong/httpd/src//http_dir.h
*** ./http_dir.h	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_dir.h	Tue Nov 28 03:02:01 1995
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_dir.h,v 1.6 1995/11/28 09:02:01 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_dir.h,v 1.6 1995/11/28 09:02:01 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_dir.o
diff -brc ./http_include.c /X11/blong/httpd/src//http_include.c
*** ./http_include.c	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_include.c	Wed Jun 12 16:11:52 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_include.c,v 1.50 1996/03/27 20:44:02 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_include.c,v 1.52 1996/06/12 20:35:28 acain Exp $
   *
   ************************************************************************
   *
***************
*** 29,34 ****
--- 29,35 ----
  # include <stdlib.h>
  #endif /* NO_STDLIB_H */
  #include <signal.h>
+ #include <setjmp.h>
  #include <errno.h>
  #include <string.h>
  #include <sys/stat.h>
***************
*** 37,42 ****
--- 38,47 ----
  #include <sys/wait.h>
  #include <ctype.h>
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "fdwrap.h"
  #include "allocate.h"
  #include "http_include.h"
***************
*** 89,99 ****
        make_env_str(reqInfo,"DOCUMENT_URI",reqInfo->url);
      }
  
- 
      freeString(uri);
      return TRUE;
  }
  
  #define GET_CHAR(f,c,r) \
   { \
     int i = getc(f); \
--- 94,105 ----
        make_env_str(reqInfo,"DOCUMENT_URI",reqInfo->url);
      }
  
      freeString(uri);
      return TRUE;
  }
  
+ /* --------------------------- Parser functions --------------------------- */
+ 
  #define GET_CHAR(f,c,r) \
   { \
     int i = getc(f); \
***************
*** 103,133 ****
     c = (char)i; \
   }
  
! /* --------------------------- Parser functions --------------------------- */
! 
! int find_string(per_request *reqInfo, FILE *fp, char *str) {
      int x,l=strlen(str),p;
      char c;
  
      p=0;
      while(1) {
!         GET_CHAR(fp,c,1);
          if(c == str[p]) {
!             if((++p) == l)
                  return 0;
          }
          else {
              if(reqInfo->out) {
                  if(p) {
                      for(x=0;x<p;x++) {
!                         rputc(str[x],reqInfo);
                      }
                  }
-                 rputc(c,reqInfo);
              }
              p=0;
          }
      }
  }
  
  char *get_tag(FILE *fp, char *tag) {
--- 109,159 ----
     c = (char)i; \
   }
  
! int find_string(per_request *reqInfo, FILE *fp, char *str) 
! {
      int x,l=strlen(str),p;
      char c;
+     char *strTmp;
+     int nTmpCount = 0;
  
+     strTmp = newString(HUGE_STRING_LEN,STR_TMP);
+ 
      p=0;
      while(1) {
! /*        GET_CHAR(fp,c,1); */
!         int i = getc(fp); 
!         if(feof(fp) || ferror(fp) || (i == -1)) { 
! 	  rputsn(reqInfo,strTmp,nTmpCount);
!           return 1; 
!         } 
! 	c = (char) i;
          if(c == str[p]) {
!             if((++p) == l) {
! 	      rputsn(reqInfo,strTmp,nTmpCount);
                return 0;
              }
+         }
          else {
              if(reqInfo->out) {
                  if(p) {
                      for(x=0;x<p;x++) {
! 		      if (nTmpCount < HUGE_STRING_LEN) {
! 		        strTmp[nTmpCount++] = str[x]; 
!                       } else {
! 			rputsn(reqInfo,strTmp, nTmpCount);
! 			nTmpCount = 0;
                        }
                      }
                  }
+ 		strTmp[nTmpCount++] = c;
+             }
              p=0;
          }
+ 	if ( nTmpCount == HUGE_STRING_LEN ) {
+ 	  rputsn(reqInfo, strTmp, nTmpCount);
+ 	  nTmpCount = 0;
  	}
+     }
  }
  
  char *get_tag(FILE *fp, char *tag) {
***************
*** 362,378 ****
              return 1;
          }
          if(!strcmp(tag,"var")) {
!             int x,i,len;
  
! 	    len = strlen(tag_val); 
!             for(x=0;reqInfo->env[x] != NULL; x++) {
!                 i = ind(reqInfo->env[x],'=');
!                 if((i == len) && !(strncmp(reqInfo->env[x],tag_val,i))) {
!                     rprintf(reqInfo,"%s",&(reqInfo->env[x][i+1]));
!                     break;
!                 }
!             }
!             if(!(reqInfo->env[x])) 
  	      rprintf(reqInfo,"(none)");
          }
  #ifndef NO_YOW
--- 388,398 ----
              return 1;
          }
          if(!strcmp(tag,"var")) {
!           char *val = return_env_value(reqInfo,tag_val);
  
! 	  if (val != NULL) 
! 	    rprintf(reqInfo,"%s",val);
!            else
  	    rprintf(reqInfo,"(none)");
          }
  #ifndef NO_YOW
***************
*** 578,584 ****
              strcpy(error,tag_val);
          else if(!strcmp(tag,"timefmt")) {
              strcpy(tf,tag_val);
!             /* Replace DATE* and LAST_MODIFIED (they should be first) */
  	    replace_env_str(reqInfo, "DATE_LOCAL", ht_time(date,tf,0));
  	    replace_env_str(reqInfo, "DATE_GMT", ht_time(date,tf,1));
  	    replace_env_str(reqInfo, "LAST_MODIFIED", ht_time(lm,tf,0));
--- 598,604 ----
              strcpy(error,tag_val);
          else if(!strcmp(tag,"timefmt")) {
              strcpy(tf,tag_val);
!             /* Replace DATE* and LAST_MODIFIED */
  	    replace_env_str(reqInfo, "DATE_LOCAL", ht_time(date,tf,0));
  	    replace_env_str(reqInfo, "DATE_GMT", ht_time(date,tf,1));
  	    replace_env_str(reqInfo, "LAST_MODIFIED", ht_time(lm,tf,0));
***************
*** 772,778 ****
--- 792,898 ----
      }
  }    
  
+ #ifdef SHTTP
  
+ int handle_certs(per_request *reqInfo, FILE *fp, char *error) {
+     extern int tsw_null_func();
+     char tag[MAX_STRING_LEN],errstr[MAX_STRING_LEN];
+     char *tag_val;
+ 
+     while(1) {
+         char *outch;
+       
+         if(!(tag_val = get_tag(fp,tag)))
+             return 1;
+         if(!strcmp(tag,"name")) {
+           if(TSW_export_cert_el(&shttp_ctx,&outch,tag_val,0,tsw_null_func)) {
+             sprintf(errstr,"unable to find cert %s in parsed file %s",
+                         tag_val, reqInfo->filename);
+ 		log_error(errstr,reqInfo->hostInfo->error_log);
+                 rprintf(reqInfo,"%s",error);
+           }
+           else {
+             rprintf(reqInfo,"%s",outch);
+             Free(outch);
+           }
+         } 
+         else if(!strcmp(tag,"done"))
+             return 0;
+         else {
+             sprintf(errstr,"unknown parameter %s to tag certs in %s",tag);
+ 	    log_error(errstr,reqInfo->hostInfo->error_log);
+             rprintf(reqInfo,"%s",error);
+         }
+     }
+ }
+ 
+ int handle_dn(per_request *reqInfo, FILE *fp, char *error) {
+     extern int tsw_null_func();
+     char tag[MAX_STRING_LEN],errstr[MAX_STRING_LEN];
+     char *tag_val;
+ 
+     while(1) {
+         if(!(tag_val = get_tag(fp,tag)))
+             return 1;
+         if(!strcmp(tag,"name")) {
+           char *outch;
+         
+           if(TSW_export_dn(&shttp_ctx,&outch,tag_val)) {
+             sprintf(errstr,"unable to find DN %s in parsed file %s",
+                         tag_val, reqInfo->filename);
+ 		log_error(errstr,reqInfo->hostInfo->error_log);
+                 rprintf(reqInfo,"%s",error);
+           }
+           else {
+             rprintf(reqInfo,"%s",outch);
+             Free(outch);
+           }
+         } 
+         else if(!strcmp(tag,"done"))
+             return 0;
+         else {
+             sprintf(errstr,"unknown parameter %s to tag DN in %s",tag,
+                     reqInfo->filename);
+ 	    log_error(errstr,reqInfo->hostInfo->error_log);
+             rprintf(reqInfo,"%s",error);
+         }
+     }
+ }
+ 
+ int handle_skey(per_request *reqInfo, FILE *fp, char *error) {
+     char tag[MAX_STRING_LEN],errstr[MAX_STRING_LEN];
+     char *tag_val;
+ 
+     while(1) {
+         if(!(tag_val = get_tag(fp,tag)))
+             return 1;
+         if(!strcmp(tag,"alg")) {
+             char *outch;
+ 
+             if(TSW_make_skey(&shttp_ctx,tag_val,&outch)) {
+                 sprintf(errstr,"unable to make server key (alg %s) in parsed file %s",
+                         tag_val, reqInfo->filename);
+ 		log_error(errstr,reqInfo->hostInfo->error_log);
+                 rprintf(reqInfo,"%s",error);
+             }            
+             else {
+               rprintf(reqInfo,"%s",outch);
+               Free(outch);
+             }
+         } 
+         else if(!strcmp(tag,"done"))
+             return 0;
+         else {
+             sprintf(errstr,"unknown parameter %s to tag s-key in %s",tag,
+                     reqInfo->filename);
+ 	    log_error(errstr,reqInfo->hostInfo->error_log);
+             rprintf(reqInfo,"%s",error);
+         }
+     }
+ }
+ #endif  /* SHTTP */
+ 
+ 
  /* -------------------------- The main function --------------------------- */
  
  /* This is a stub which parses a file descriptor. */
***************
*** 822,827 ****
--- 942,955 ----
                  ret=handle_fsize(reqInfo,fp,error,sizefmt);
              else if(!strcmp(directive,"flastmod"))
                  ret=handle_flastmod(reqInfo,fp,error,timefmt);
+ #ifdef SHTTP
+             else if(!strcmp(directive,"certs"))
+                 ret=handle_certs(reqInfo,fp,error);
+             else if(!strcmp(directive,"s-key"))
+                 ret=handle_skey(reqInfo,fp,error);
+             else if(!strcmp(directive,"dn"))
+                 ret=handle_dn(reqInfo,fp,error);
+ #endif /* SHTTP */
  #ifndef NO_YOW
  	    else if(!strcmp(directive,"yow"))
  		ret=handle_yow(reqInfo,fp,error);
***************
*** 882,886 ****
--- 1010,1015 ----
      add_common_vars(reqInfo);
  
      send_parsed_content(reqInfo,fp,noexec);
+     rflush(reqInfo);
      FClose(fp);
  }
diff -brc ./http_include.h /X11/blong/httpd/src//http_include.h
*** ./http_include.h	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_include.h	Wed Mar 27 14:44:04 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_include.h,v 1.7 1996/03/27 20:44:04 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_include.h,v 1.7 1996/03/27 20:44:04 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_include.o
diff -brc ./http_ipc.c /X11/blong/httpd/src//http_ipc.c
*** ./http_ipc.c	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_ipc.c	Wed Jun  5 21:44:40 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_ipc.c,v 1.22 1996/02/22 23:46:59 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_ipc.c,v 1.23 1996/06/06 02:44:40 blong Exp $
   *
   ************************************************************************
   *
***************
*** 42,47 ****
--- 42,50 ----
  
  #ifdef FD_BSD 
  # include <sys/uio.h>
+ # ifdef NEED_SYS_UN_H
+ #  include <sys/un.h>
+ # endif /* NEED_SYS_UN_H */
  # include <errno.h>
  # include <stddef.h>
  #elif defined(FD_SYSV)
diff -brc ./http_ipc.h /X11/blong/httpd/src//http_ipc.h
*** ./http_ipc.h	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_ipc.h	Mon Oct 23 13:07:14 1995
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_ipc.h,v 1.3 1995/07/25 06:43:36 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_ipc.h,v 1.3 1995/07/25 06:43:36 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_ipc.o
Only in /X11/blong/httpd/src/: http_kerberos.c
Only in /X11/blong/httpd/src/: http_kerberos.h
Only in /X11/blong/httpd/src/: http_kerberos.o
diff -brc ./http_log.c /X11/blong/httpd/src//http_log.c
*** ./http_log.c	Tue Jun 25 17:06:16 1996
--- /X11/blong/httpd/src//http_log.c	Wed Jun 12 16:11:54 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_log.c,v 1.84 1996/04/05 18:54:59 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_log.c,v 1.86 1996/06/12 20:35:31 acain Exp $
   *
   ************************************************************************
   *
***************
*** 36,42 ****
--- 36,51 ----
  #endif /* NO_MALLOC_H */
  #include <sys/stat.h>
  #include <string.h>
+ #include <setjmp.h>
  #include "constants.h"
+ #ifdef LOG_TIMES
+ # include <sys/times.h>
+ # include <time.h>
+ #endif /* LOG_TIMES */
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "allocate.h"
  #include "http_log.h"
  #include "http_request.h"
***************
*** 49,55 ****
  #include "util.h"
  #include "open_logfile.h"
  
- 
  const char StatLine200[] = "200 Document follows";
  const char StatLine204[] = "204 No Content";
  const char StatLine206[] = "206 Partial Content";
--- 58,63 ----
***************
*** 66,72 ****
  const char StatLine503[] = "503 Service Unavailable";
  char error_msg[MAX_STRING_LEN];
  
- /* Moved to http_request.c */
  int ErrorStat=0;
  
  static int xfer_flags = ( O_WRONLY | O_APPEND | O_CREAT );
--- 74,79 ----
***************
*** 173,187 ****
      long timz;
      struct tm *t;
      char *tstr,sign;
! #ifdef LOG_DURATION
!     extern time_t request_time;
!     time_t duration = request_time ? (time(NULL) - request_time) : 0;
! #endif /* LOG_DURATION */
  
      str = newString(HUGE_STRING_LEN,STR_TMP);
      tstr = newString(MAX_STRING_LEN,STR_TMP);
  
  
      t = get_gmtoff(&timz);
      sign = (timz < 0 ? '-' : '+');
      if(timz < 0) 
--- 180,206 ----
      long timz;
      struct tm *t;
      char *tstr,sign;
! #ifdef LOG_TIMES
!     struct tms times_end;
!     struct timeval time_end;
! #endif /* LOG_TIMES */
  
      str = newString(HUGE_STRING_LEN,STR_TMP);
      tstr = newString(MAX_STRING_LEN,STR_TMP);
  
+ #ifdef LOG_TIMES
+     if (reqInfo->hostInfo->log_opts & LOG_REALTIME)
+       gettimeofday(&time_end, NULL);
  
+     if (reqInfo->hostInfo->log_opts & LOG_CPUTIME) {
+       times(&times_end);
+       times_end.tms_stime -= reqInfo->times_recv.tms_stime;
+       times_end.tms_utime -= reqInfo->times_recv.tms_utime;
+       times_end.tms_cstime -= reqInfo->times_recv.tms_cstime;
+       times_end.tms_cutime -= reqInfo->times_recv.tms_cutime;
+     }
+ #endif /* LOG_TIMES */
+ 
      t = get_gmtoff(&timz);
      sign = (timz < 0 ? '-' : '+');
      if(timz < 0) 
***************
*** 212,218 ****
         else
  	strcat(str," -");
      }
!     if (reqInfo->hostInfo->referer_ignore && reqInfo->inh_referer[0]) {
         char *str1;
         int bIgnore = 0;
         
--- 231,239 ----
         else
  	strcat(str," -");
      }
!     if ((reqInfo->hostInfo->log_opts & LOG_REFERER) &&
!          reqInfo->hostInfo->referer_ignore && reqInfo->inh_referer[0]) 
!     {
         char *str1;
         int bIgnore = 0;
         
***************
*** 234,249 ****
         }
         freeString(str1);
      }
- #ifdef LOG_DURATION
-     sprintf(str+strlen(str), " %ld", duration);
- #endif /* LOG_DURATION */
  
      if (!(reqInfo->hostInfo->log_opts & LOG_COMBINED)) {
-       strcat(str,"\n");
-       write(reqInfo->hostInfo->xfer_log,str,strlen(str));
  
        /* log the user agent */
!       if (reqInfo->inh_agent[0]) {
          if (reqInfo->hostInfo->log_opts & LOG_DATE)
  	 fprintf(reqInfo->hostInfo->agent_log, "[%s] %s\n",tstr, 
  		 reqInfo->inh_agent);
--- 255,267 ----
         }
         freeString(str1);
      }
  
      if (!(reqInfo->hostInfo->log_opts & LOG_COMBINED)) {
  
        /* log the user agent */
!       if ((reqInfo->hostInfo->log_opts & LOG_USERAGENT) && 
!            reqInfo->inh_agent[0])
!       {
          if (reqInfo->hostInfo->log_opts & LOG_DATE)
  	 fprintf(reqInfo->hostInfo->agent_log, "[%s] %s\n",tstr, 
  		 reqInfo->inh_agent);
***************
*** 252,258 ****
  	fflush(reqInfo->hostInfo->agent_log);
        }
        /* log the referer */
!       if (reqInfo->inh_referer[0]) {
  	if (reqInfo->hostInfo->log_opts & LOG_DATE)
  	  fprintf(reqInfo->hostInfo->referer_log, "[%s] %s -> %s\n",tstr,
  	  	  reqInfo->inh_referer, reqInfo->url);
--- 270,278 ----
  	fflush(reqInfo->hostInfo->agent_log);
        }
        /* log the referer */
!       if ((reqInfo->hostInfo->log_opts & LOG_REFERER) &&
!            reqInfo->inh_referer[0]) 
!       {
  	if (reqInfo->hostInfo->log_opts & LOG_DATE)
  	  fprintf(reqInfo->hostInfo->referer_log, "[%s] %s -> %s\n",tstr,
  	  	  reqInfo->inh_referer, reqInfo->url);
***************
*** 262,277 ****
  	fflush(reqInfo->hostInfo->referer_log);
        }
      } else {
!       if (reqInfo->inh_referer[0])
          sprintf(str,"%s \"%s\"",str,reqInfo->inh_referer);
         else
  	strcat(str," \"\"");
!       if (reqInfo->inh_agent[0]) 
! 	sprintf(str,"%s \"%s\"\n",str,reqInfo->inh_agent);
         else
! 	strcat(str," \"\"\n");
!       write(reqInfo->hostInfo->xfer_log,str,strlen(str));
      }
      freeString(str);
      freeString(tstr);
  }
--- 282,320 ----
  	fflush(reqInfo->hostInfo->referer_log);
        }
      } else {
!       if ((reqInfo->hostInfo->log_opts & LOG_REFERER) && 
!            reqInfo->inh_referer[0])
          sprintf(str,"%s \"%s\"",str,reqInfo->inh_referer);
         else
  	strcat(str," \"\"");
!       if ((reqInfo->hostInfo->log_opts & LOG_USERAGENT) &&
!            reqInfo->inh_agent[0]) 
! 	sprintf(str,"%s \"%s\"",str,reqInfo->inh_agent);
         else
! 	strcat(str," \"\"");
      }
+ #ifdef LOG_TIMES
+     if (reqInfo->hostInfo->log_opts & LOG_REALTIME) {
+       sprintf(str, "%s %d/%d/%d", str,
+         (((reqInfo->time_process.tv_sec*1000)+(reqInfo->time_process.tv_usec/1000)) -
+         ((reqInfo->time_recv.tv_sec*1000)+(reqInfo->time_recv.tv_usec/1000))),
+         (((reqInfo->time_send.tv_sec*1000)+(reqInfo->time_send.tv_usec/1000)) -
+         ((reqInfo->time_process.tv_sec*1000)+(reqInfo->time_process.tv_usec/1000))),
+         (((time_end.tv_sec*1000)+(time_end.tv_usec/1000)) -
+         ((reqInfo->time_send.tv_sec*1000)+(reqInfo->time_send.tv_usec/1000))));
+     } else if (reqInfo->hostInfo->log_opts & LOG_CPUTIME)
+       strcat(str, " -");
+ 
+     if (reqInfo->hostInfo->log_opts & LOG_CPUTIME) {
+       sprintf(str, "%s %d/%d/%d", str,
+               times_end.tms_stime*1000/clk_ticks,
+               times_end.tms_utime*1000/clk_ticks,
+               (times_end.tms_cutime+times_end.tms_cstime)*1000/clk_ticks);
+     } else if (reqInfo->hostInfo->log_opts & LOG_REALTIME)
+       strcat(str, " -");
+ #endif /* LOG_TIMES */
+     strcat(str,"\n");
+     write(reqInfo->hostInfo->xfer_log,str,strlen(str));
      freeString(str);
      freeString(tstr);
  }
***************
*** 610,615 ****
--- 653,667 ----
      }
      rflush(reqInfo);
      freeString(arguments);
+ #ifdef SHTTP
+ /* SHTTP can't die here, it must be wrapped on the way out. */
+     if (!RetVal && (reqInfo->RequestFlags & DOING_SHTTP) && shttp_jump_set)
+ #ifdef NO_SIGLONGJMP
+       longjmp(shttp_fail,1);
+ #else
+       siglongjmp(shttp_fail,1);
+ #endif /* NO_SIGLONGJMP */
+ #endif /* SHTTP */
      if (!RetVal) 
        htexit(reqInfo,1,die_type);
      return RetVal;
***************
*** 636,650 ****
      char *tmp;
  
      if (host->num_doc_errors == 0) {
!       host->doc_errors = (ErrorDoc **) malloc(sizeof(ErrorDoc*));
      } else {
!       host->doc_errors = (ErrorDoc **) realloc(host->doc_errors,
  					       (host->num_doc_errors+1) *
  						sizeof(ErrorDoc*));
      }
!     host->doc_errors[host->num_doc_errors]=(ErrorDoc *)malloc(sizeof(ErrorDoc));
  
!     tmp = (char *) malloc(strlen(name)+1);
      strcpy(tmp,name);
      
      host->doc_errors[host->num_doc_errors]->DocErrorNum = atoi(errornum);
--- 688,702 ----
      char *tmp;
  
      if (host->num_doc_errors == 0) {
!       host->doc_errors = (ErrorDoc **) Malloc(sizeof(ErrorDoc*));
      } else {
!       host->doc_errors = (ErrorDoc **) Realloc(host->doc_errors,
  					       (host->num_doc_errors+1) *
  						sizeof(ErrorDoc*));
      }
!     host->doc_errors[host->num_doc_errors]=(ErrorDoc *)Malloc(sizeof(ErrorDoc));
  
!     tmp = (char *) Malloc(strlen(name)+1);
      strcpy(tmp,name);
      
      host->doc_errors[host->num_doc_errors]->DocErrorNum = atoi(errornum);
***************
*** 676,684 ****
      int x=0;
  
      for (x = 0 ; x < host->num_doc_errors; x++) {
!       free(host->doc_errors[x]->DocErrorFile);
!       free(host->doc_errors[x]);
      }
  
!     free(host->doc_errors);
  }
--- 728,736 ----
      int x=0;
  
      for (x = 0 ; x < host->num_doc_errors; x++) {
!       Free(host->doc_errors[x]->DocErrorFile);
!       Free(host->doc_errors[x]);
      }
  
!     Free(host->doc_errors);
  }
diff -brc ./http_log.h /X11/blong/httpd/src//http_log.h
*** ./http_log.h	Tue Jun 25 17:06:17 1996
--- /X11/blong/httpd/src//http_log.h	Wed Jun  5 21:44:44 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_log.h,v 1.18 1996/03/06 23:21:06 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_log.h,v 1.19 1996/06/06 02:44:44 blong Exp $
   *
   ************************************************************************
   *
***************
*** 33,38 ****
--- 33,42 ----
  #define LOG_SEPARATE    ~(LOG_COMBINED)
  #define LOG_SERVERNAME  2
  #define LOG_DATE	4
+ #define LOG_REALTIME	8
+ #define LOG_CPUTIME	16
+ #define LOG_REFERER	32
+ #define LOG_USERAGENT	64
  
  #define SERVER_SUPPORT "httpd@ncsa.uiuc.edu"
  
***************
*** 68,74 ****
  void error_log2stderr(FILE *error_log);
  
  void title_html(per_request *reqInfo, char *msg);
- void begin_http_header(per_request *reqInfo);
  
  int die(per_request *reqInfo, int type, char *err_string);
  
--- 72,77 ----
Only in /X11/blong/httpd/src/: http_log.o
diff -brc ./http_mime.c /X11/blong/httpd/src//http_mime.c
*** ./http_mime.c	Tue Jun 25 17:06:17 1996
--- /X11/blong/httpd/src//http_mime.c	Wed Jun  5 21:44:46 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_mime.c,v 1.106 1996/03/13 18:28:39 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_mime.c,v 1.108 1996/06/06 02:44:46 blong Exp $
   *
   ************************************************************************
   *
***************
*** 52,61 ****
  #include "http_request.h"
  #include "util.h"
  
- #if defined(KRB4) || defined(KRB5)
- #define HAVE_KERBEROS
- #endif /* defined(KRB4) || defined(KRB5) */
- 
  #if 1
  #define hash(i) (isalpha(i) ? (tolower(i)) - 'a' : 26)
  #else
--- 52,57 ----
***************
*** 99,126 ****
      for(x=0;x<27;x++) {
          p=types[x];
          while(p) {
!             free(p->ext);
!             free(p->ct);
              q=p;
              p=p->next;
!             free(q);
          }
      }
      p=forced_types;
      while(p) {
!         free(p->ext);
!         free(p->ct);
          q=p;
          p=p->next;
!         free(q);
      }
      p=encoding_types;
      while(p) {
!         free(p->ext);
!         free(p->ct);
          q=p;
          p=p->next;
!         free(q);
      }
  }
  
--- 95,122 ----
      for(x=0;x<27;x++) {
          p=types[x];
          while(p) {
!             Free(p->ext);
!             Free(p->ct);
              q=p;
              p=p->next;
!             Free(q);
          }
      }
      p=forced_types;
      while(p) {
!         Free(p->ext);
!         Free(p->ct);
          q=p;
          p=p->next;
!         Free(q);
      }
      p=encoding_types;
      while(p) {
!         Free(p->ext);
!         Free(p->ct);
          q=p;
          p=p->next;
!         Free(q);
      }
  }
  
***************
*** 149,163 ****
      while(!(cfg_getline(l,MAX_STRING_LEN,f))) {
          if(l[0] == '#') continue;
          cfg_getword(w,l);
!         if(!(ct = (char *)malloc(sizeof(char) * (strlen(w) + 1))))
              die(&reqInfo,SC_NO_MEMORY,"init_mime");
          strcpy(ct,w);
  
          while(l[0]) {
              cfg_getword(w,l);
!             if(!(me = (struct mime_ext *)malloc(sizeof(struct mime_ext))))
                  die(&reqInfo,SC_NO_MEMORY,"init_mime");
!             if(!(me->ext = (char *)malloc(sizeof(char) * (strlen(w)+1))))
                  die(&reqInfo,SC_NO_MEMORY,"init_mime");
              for(x=0;w[x];x++)
                  me->ext[x] = (islower(w[x]) ? w[x] : tolower(w[x]));
--- 145,159 ----
      while(!(cfg_getline(l,MAX_STRING_LEN,f))) {
          if(l[0] == '#') continue;
          cfg_getword(w,l);
!         if(!(ct = (char *)Malloc(sizeof(char) * (strlen(w) + 1))))
              die(&reqInfo,SC_NO_MEMORY,"init_mime");
          strcpy(ct,w);
  
          while(l[0]) {
              cfg_getword(w,l);
!             if(!(me = (struct mime_ext *)Malloc(sizeof(struct mime_ext))))
                  die(&reqInfo,SC_NO_MEMORY,"init_mime");
!             if(!(me->ext = (char *)Malloc(sizeof(char) * (strlen(w)+1))))
                  die(&reqInfo,SC_NO_MEMORY,"init_mime");
              for(x=0;w[x];x++)
                  me->ext[x] = (islower(w[x]) ? w[x] : tolower(w[x]));
***************
*** 167,173 ****
              me->next=NULL;
              hash_insert(me);
          }
!         free(ct);
      }
      FClose(f);
  }
--- 163,169 ----
              me->next=NULL;
              hash_insert(me);
          }
!         Free(ct);
      }
      FClose(f);
  }
***************
*** 291,299 ****
    tmp = mimes;
    while (mimes && (mimes != Saved_Forced)) {
      mimes = mimes->next;
!     free(tmp->ext);
!     free(tmp->ct);
!     free(tmp);
      tmp = mimes;
    }
  
--- 287,295 ----
    tmp = mimes;
    while (mimes && (mimes != Saved_Forced)) {
      mimes = mimes->next;
!     Free(tmp->ext);
!     Free(tmp->ct);
!     Free(tmp);
      tmp = mimes;
    }
  
***************
*** 304,312 ****
  
    while (mimes && (mimes != Saved_Encoding)) {
      mimes = mimes->next;
!     free(tmp->ext);
!     free(tmp->ct);
!     free(tmp);
      tmp = mimes;
    }
  
--- 300,308 ----
  
    while (mimes && (mimes != Saved_Encoding)) {
      mimes = mimes->next;
!     Free(tmp->ext);
!     Free(tmp->ct);
!     Free(tmp);
      tmp = mimes;
    }
  
***************
*** 316,322 ****
  void add_type(per_request *reqInfo, char *fn, char *t) {
      struct mime_ext *n;
  
!     if(!(n=(struct mime_ext *)malloc(sizeof(struct mime_ext))))
          die(reqInfo,SC_NO_MEMORY,"add_type");
  
      if(!(n->ext = strdup(fn)))
--- 312,318 ----
  void add_type(per_request *reqInfo, char *fn, char *t) {
      struct mime_ext *n;
  
!     if(!(n=(struct mime_ext *)Malloc(sizeof(struct mime_ext))))
          die(reqInfo,SC_NO_MEMORY,"add_type");
  
      if(!(n->ext = strdup(fn)))
***************
*** 330,336 ****
  void add_encoding(per_request *reqInfo, char *fn, char *t) {
      struct mime_ext *n;
  
!     if(!(n=(struct mime_ext *)malloc(sizeof(struct mime_ext))))
          die(reqInfo, SC_NO_MEMORY,"add_encoding");
  
      if(!(n->ext = strdup(fn)))
--- 326,332 ----
  void add_encoding(per_request *reqInfo, char *fn, char *t) {
      struct mime_ext *n;
  
!     if(!(n=(struct mime_ext *)Malloc(sizeof(struct mime_ext))))
          die(reqInfo, SC_NO_MEMORY,"add_encoding");
  
      if(!(n->ext = strdup(fn)))
diff -brc ./http_mime.h /X11/blong/httpd/src//http_mime.h
*** ./http_mime.h	Tue Jun 25 17:06:17 1996
--- /X11/blong/httpd/src//http_mime.h	Thu Feb 22 17:47:04 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_mime.h,v 1.19 1996/02/22 23:47:04 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_mime.h,v 1.19 1996/02/22 23:47:04 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_mime.o
Only in /X11/blong/httpd/src/: http_nis.c
Only in /X11/blong/httpd/src/: http_nis.h
Only in /X11/blong/httpd/src/: http_nis.o
Only in /X11/blong/httpd/src/: http_pem.c
diff -brc ./http_request.c /X11/blong/httpd/src//http_request.c
*** ./http_request.c	Tue Jun 25 17:06:17 1996
--- /X11/blong/httpd/src//http_request.c	Wed Jun 12 16:11:54 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_request.c,v 1.113 1996/04/05 18:55:02 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_request.c,v 1.116 1996/06/12 20:35:34 acain Exp $
   *
   ************************************************************************
   *
***************
*** 39,49 ****
--- 39,56 ----
  #include <ctype.h>
  #include <setjmp.h>
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "allocate.h"		/* for freeString() */
  #include "cgi.h"		/* for exec_cgi_script() */
  #ifdef FCGI_SUPPORT
  # include "fcgi.h"		/* for FastCgiHandler() */
  #endif /* FCGI */
+ #ifdef SSL_SUPPORT
+ # include "http_ssl.h"		/* for SSL defines */
+ #endif /* SSL_SUPPORT */
  #include "env.h"		/* for free_env() */
  #include "http_access.h"	/* for reset_security() */
  #include "http_alias.h"		/* For translate_name() */
***************
*** 72,81 ****
  char as_requested[HUGE_STRING_LEN];
  char failed_request[HUGE_STRING_LEN];
  char failed_url[HUGE_STRING_LEN];
- #ifdef LOG_DURATION
- time_t request_time = 0;
- #endif /* LOG_DURATION */
  
  /* String constants for the request.  Numbers are in constants.h */
  char *methods[METHODS] = {"GET","HEAD","POST","PUT","DELETE","SECURE",
  			  "LINK","UNLINK"};
--- 79,90 ----
  char as_requested[HUGE_STRING_LEN];
  char failed_request[HUGE_STRING_LEN];
  char failed_url[HUGE_STRING_LEN];
  
+ #ifdef SHTTP
+ JMP_BUF shttp_fail;
+ int shttp_jump_set = FALSE;
+ #endif /* SHTTP */
+ 
  /* String constants for the request.  Numbers are in constants.h */
  char *methods[METHODS] = {"GET","HEAD","POST","PUT","DELETE","SECURE",
  			  "LINK","UNLINK"};
***************
*** 98,104 ****
  
   
      if (RealInit) {
!         newInfo = (per_request *) malloc(sizeof(per_request));
  	req_count++;
  	reqInfo = newInfo;
  	reqInfo->ownDNS = TRUE;
--- 107,113 ----
  
   
      if (RealInit) {
!         newInfo = (per_request *) Malloc(sizeof(per_request));
  	req_count++;
  	reqInfo = newInfo;
  	reqInfo->ownDNS = TRUE;
***************
*** 127,133 ****
  
      reqInfo->ownENV = TRUE;
      reqInfo->env = NULL;
-     reqInfo->env_len = NULL;
      reqInfo->num_env = 0;
      reqInfo->max_env = 0;
  
--- 136,141 ----
***************
*** 187,192 ****
--- 195,213 ----
  #endif /* CONTENT_MD5 */
      reqInfo->outh_cgi = NULL;
  
+ #ifdef SHTTP
+     if (!(reqInfo->shttp_info = (msginfo *)Malloc(sizeof(msginfo)))) {
+         fprintf(stderr,"\nADC ZZZ: malloc failed!!\n");
+         fflush(stderr);
+     }
+     TSW_init_msginfo(reqInfo->shttp_info);
+ 
+     reqInfo->privacy_enhancements = NULL;
+     reqInfo->shttp_info->youOpts = TSW_create_you_opts();
+     reqInfo->shttp_info->meOpts = TSW_create_me_opts();
+ 
+ #endif /* SHTTP */
+ 
      as_requested[0] = '\0';
      failed_url[0] = '\0';
      failed_request[0] = '\0';
***************
*** 217,223 ****
  per_request *continue_request(per_request *reqInfo, int options) {
      per_request *newInfo;
  
!     newInfo = (per_request *)malloc(sizeof(per_request));
      req_count++;
      newInfo->status = reqInfo->status;
      newInfo->status_line = NULL;
--- 238,244 ----
  per_request *continue_request(per_request *reqInfo, int options) {
      per_request *newInfo;
  
!     newInfo = (per_request *)Malloc(sizeof(per_request));
      req_count++;
      newInfo->status = reqInfo->status;
      newInfo->status_line = NULL;
***************
*** 225,237 ****
      if (options & KEEP_ENV) {
  	newInfo->ownENV = FALSE;
  	newInfo->env = reqInfo->env;
- 	newInfo->env_len = reqInfo->env_len;
  	newInfo->num_env = reqInfo->num_env;
  	newInfo->max_env = reqInfo->max_env;
      } else {
          newInfo->ownENV = TRUE;
          newInfo->env = NULL;
-         newInfo->env_len = NULL;
          newInfo->num_env = 0;
          newInfo->max_env = 0;
      }
--- 246,256 ----
***************
*** 302,308 ****
--- 321,341 ----
  	newInfo->path_info[0] = '\0';
  	newInfo->filename[0] = '\0';
      }
+ #ifdef SHTTP
+     newInfo->shttp_info = TSW_copy_msginfo(reqInfo->shttp_info);
+     if (newInfo == NULL) {
+ 	fprintf(stderr,"\nADC ZZZ: copy_msginfo failed!!\n");
+   	fflush(stderr);
+     }
  
+     newInfo->privacy_enhancements = NULL;
+ /* for debugging ZZZZ
+     if (reqInfo->privacy_enhancements)
+ 	strcpy(newInfo->privacy_enhancements,reqInfo->privacy_enhancements);
+ */
+ #endif /* SHTTP */
+ 
+ 
      /* Copy all in headers */
      strcpy(newInfo->inh_agent,reqInfo->inh_agent);
      strcpy(newInfo->inh_referer,reqInfo->inh_referer);
***************
*** 351,360 ****
  	reqInfo->remote_name = NULL;
  	reqInfo->remote_host = NULL;
  	reqInfo->remote_ip = NULL;
  #ifdef CONTENT_MD5
! 	if (reqInfo->outh_content_md5 != NULL) free(reqInfo->outh_content_md5);
  #endif /* CONTENT_MD5 */
! 	if (reqInfo->outh_cgi != NULL) free(reqInfo->outh_cgi);
  
  	
  	if (reqInfo->ownENV && reqInfo->env) {
--- 384,400 ----
  	reqInfo->remote_name = NULL;
  	reqInfo->remote_host = NULL;
  	reqInfo->remote_ip = NULL;
+ #ifdef SHTTP
+         if (reqInfo->privacy_enhancements != NULL)
+ 	  freeString(reqInfo->privacy_enhancements);
+ 	reqInfo->privacy_enhancements = NULL;
+ 
+ 	Free(reqInfo->shttp_info);
+ #endif /* SHTTP */
  #ifdef CONTENT_MD5
! 	if (reqInfo->outh_content_md5 != NULL) Free(reqInfo->outh_content_md5);
  #endif /* CONTENT_MD5 */
! 	if (reqInfo->outh_cgi != NULL) Free(reqInfo->outh_cgi);
  
  	
  	if (reqInfo->ownENV && reqInfo->env) {
***************
*** 361,372 ****
  	  free_env(reqInfo); 
  	}
  	if (reqInfo->ownSB && reqInfo->sb) {
! 	  free(reqInfo->sb);
  	  reqInfo->sb = NULL;
  	  sockbuf_count--;
  	} 
  	if (reqInfo->cgi_buf) {
! 	  free(reqInfo->cgi_buf);
  	  reqInfo->cgi_buf = NULL;
  	  cgibuf_count--;
  	} 
--- 401,412 ----
  	  free_env(reqInfo); 
  	}
  	if (reqInfo->ownSB && reqInfo->sb) {
! 	  Free(reqInfo->sb);
  	  reqInfo->sb = NULL;
  	  sockbuf_count--;
  	} 
  	if (reqInfo->cgi_buf) {
! 	  Free(reqInfo->cgi_buf);
  	  reqInfo->cgi_buf = NULL;
  	  cgibuf_count--;
  	} 
***************
*** 379,385 ****
  	  return;
          }
  	tmp = reqInfo->next;
! 	free(reqInfo);
  	req_count--;
  	reqInfo = tmp;
  	gCurrentRequest = reqInfo;	
--- 419,425 ----
  	  return;
          }
  	tmp = reqInfo->next;
! 	Free(reqInfo);
  	req_count--;
  	reqInfo = tmp;
  	gCurrentRequest = reqInfo;	
***************
*** 409,415 ****
      
      /* extract the URL, and args if present */
      url = strtok (NULL, "\t\r ");
!     if (url && (chp = strchr (url, '?'))) {
  	*chp++ = '\0';
  	strcpy (reqInfo->args, chp);
      }
--- 449,456 ----
      
      /* extract the URL, and args if present */
      url = strtok (NULL, "\t\r ");
!     if (!url) die(reqInfo,SC_BAD_REQUEST,"Incomplete request.");
!     if ((chp = strchr (url, '?'))) {
  	*chp++ = '\0';
  	strcpy (reqInfo->args, chp);
      }
***************
*** 482,487 ****
--- 523,538 ----
      char *field_val;
      int options = 0;
  
+ #ifdef SSL_SUPPORT
+     if (reqInfo->RequestFlags & DOING_SSL) 
+       options |= G_SSL_READ;
+ #endif /* SSL_SUPPORT */
+ 
+ #ifdef SHTTP
+     if(reqInfo->method == M_SECURE) 
+       options |= G_SINGLE_CHAR;
+ #endif /* SHTTP */
+ 
      while(getline(reqInfo->sb,field_type,HUGE_STRING_LEN-1,options,
  		  timeout) != -1) {
  
***************
*** 488,498 ****
          if(!field_type[0]) 
              return;
  
- 				/* ADC hack ZZZZ */
- /*  
- fprintf(stderr,">%s\n",field_type);
- fflush(stderr);
- */
          if(!(field_val = strchr(field_type,':')))
              continue; 
  
--- 539,544 ----
***************
*** 530,535 ****
--- 576,584 ----
          if(!strcasecmp(field_type,"Connection")) {
  	    if (!strcasecmp(field_val, "Keep-Alive") && 
  		keep_alive.bAllowKeepAlive)
+ #ifdef SSL_SUPPORT
+ 		if (!ssl_enabled) 
+ #endif /* SSL_SUPPORT */
  		keep_alive.bKeepAlive = 1;
  	} else
          if(!strcasecmp(field_type,"User-agent")) {
***************
*** 544,549 ****
--- 593,613 ----
              strncpy(reqInfo->inh_if_mod_since,field_val, MAX_STRING_LEN);
  	    reqInfo->inh_if_mod_since[MAX_STRING_LEN-1] = '\0';
  	} 
+ #ifdef SHTTP
+ /* Quite frankly, this doesn't do anything, so fuq it.  ZZZZZ */
+ /*	else if(!strcasecmp(field_type,"Security-Scheme")) {
+ 	  TSW_trimbuf(field_val);
+ 	  if (!strncasecmp(field_val,"S-HTTP",6)) {
+ 	  } 
+ 	}
+ */
+ 	if (reqInfo->RequestFlags & DOING_SHTTP) {
+ 	     TSW_proc_you_opt_val(&(reqInfo->shttp_info->youOpts),field_type,
+ 			   field_val);
+         } else if (reqInfo->method == M_SECURE) {
+ 	  TSW_shttp_parse_headerval(reqInfo->shttp_info,field_type,field_val);
+         }
+ #endif /* SHTTP */
          http2cgi(unrec_hdr, field_type);
  	strcpy (unrec_hdr_val, field_val);
          if(reqInfo->env) {
***************
*** 604,614 ****
  {
     int options = 0;
  
      signal(SIGPIPE,send_fd_timed_out);
  
! #ifdef LOG_DURATION
!     request_time = 0;
! #endif /* LOG_DURATION */
  
      if (reqInfo->sb == NULL) {
        reqInfo->sb = new_sock_buf(reqInfo,reqInfo->in);
--- 668,695 ----
  {
     int options = 0;
  
+ #ifdef LOG_TIMES
+    if (reqInfo->hostInfo->log_opts & LOG_CPUTIME)
+      times(&(reqInfo->times_recv));
+ 
+    if (reqInfo->hostInfo->log_opts & LOG_REALTIME)
+      gettimeofday(&(reqInfo->time_recv), NULL);
+ #endif /* LOG_TIMES */
+ 
     signal(SIGPIPE,send_fd_timed_out);
  
! #ifdef SSL_SUPPORT
!      if (!(reqInfo->RequestFlags & DOING_SSL) && (ssl_enabled == TRUE))  {
!        if (!ssl_request_init(reqInfo)) 
! 	 return;
!        options |= G_SSL_READ;
!      }
! /* ssl_fprintf calls require that this be null to test
!  * for being an ssl stream
!  */
! /*   if (!ssl_only_flag || !ssl_active_flag)
!      ssl_con=NULL; */
! #endif /* SSL_SUPPORT */
     
      if (reqInfo->sb == NULL) {
        reqInfo->sb = new_sock_buf(reqInfo,reqInfo->in);
***************
*** 615,620 ****
--- 696,705 ----
        sockbuf_count++;
      }
  
+ #ifdef SHTTP
+     options |= G_SINGLE_CHAR;
+ #endif /* SHTTP */
+ 
      if (getline(reqInfo->sb, as_requested, HUGE_STRING_LEN,
  		options, timeout) == -1)
          return;
***************
*** 622,631 ****
      if(!as_requested[0]) 
          return;
  
- #ifdef LOG_DURATION
-        request_time = time(NULL);
- #endif /* LOG_DURATION */
- 
      strcpy(the_request, as_requested);
  
  #ifdef SETPROCTITLE
--- 707,712 ----
***************
*** 646,652 ****
        get_remote_host(reqInfo);
      }
  
!     process_request(reqInfo);
  
  }
  
--- 727,862 ----
        get_remote_host(reqInfo);
      }
  
! #ifdef SHTTP
!     if(reqInfo->RequestFlags & DOING_SHTTP) {
!       /* Set up temp file to put reply into, then continue.
!        * Also set up here for a failure siglongjmp.
!        */
  
+       reqInfo->out = TSW_secure_tmp_file();
+ #ifdef NO_SIGLONGJMP
+       if (setjmp(shttp_fail)) {
+ #else
+       if (sigsetjmp(shttp_fail,1)) {
+ #endif /* NO_SIGLONGJMP */
+         shttp_jump_set = FALSE;
+         return;
+       }
+       shttp_jump_set = TRUE;
+     } 
+       
+     if(reqInfo->method == M_SECURE) {
+       int result;
+       int s2;
+       extern int tsw_null_func();
+       per_request *newInfo;
+       int shttp_sugg_process = 0;
+       int shttp_allow_process = 0;
+       
+       if (reqInfo->remote_host != NULL) 
+ 	reqInfo->shttp_info->peer_hostname = reqInfo->remote_host;
+        else 
+ 	reqInfo->shttp_info->peer_hostname = reqInfo->remote_name;
+       reqInfo->shttp_info->peer_port = 0;
+       reqInfo->RequestFlags |= DOING_SHTTP; 
+ 
+       if (result = TSW_io_shttp_unwrap(&shttp_ctx,reqInfo->in,&s2,reqInfo->shttp_info,
+ 				0,tsw_null_func())) 
+       {
+ 	log_error(TSW_shttp_explain_error(result), 
+                   	reqInfo->hostInfo->error_log);
+ 	fflush(reqInfo->hostInfo->error_log);
+ 
+         close(s2);
+         die(reqInfo,SC_BAD_REQUEST,TSW_shttp_explain_error(result));
+       }
+ 
+ #ifdef SHTTP_DEBUG
+     if(TSW_is_encrypted(reqInfo->shttp_info))
+ 	fprintf(stderr,"The request is encrypted !\n");
+     else
+ 	fprintf(stderr,"The request is NOT encrypted !\n");
+ 
+     if(TSW_is_signed(reqInfo->shttp_info))
+ 	fprintf(stderr,"The request is signed!\n");
+     else
+ 	fprintf(stderr,"The request is NOT signed!\n");
+ 
+     if(TSW_is_authenticated(reqInfo->shttp_info))
+ 	fprintf(stderr,"The request is authenticated!\n");
+     else
+ 	fprintf(stderr,"The request is NOT authenticated!\n");
+ 
+     fflush(stderr);
+ #endif /* SHTTP_DEBUG */
+ 
+       strcpy(reqInfo->auth_type,"S-HTTP");
+       /* kludge to set up info for scripts (?) */
+       if (reqInfo->shttp_info->signed_dn)
+ 	strcpy(reqInfo->auth_user,reqInfo->shttp_info->signed_dn);
+       newInfo = continue_request(reqInfo,KEEP_AUTH | NEW_SOCK_BUF);
+       newInfo->in = s2;
+ 
+       newInfo->RequestFlags |= DOING_SHTTP;	/* added by ADC ZZZ */
+ 
+ /* the next three lines are adam debugging. they may not be needed  ADC   ZZZ 
+ */
+       newInfo->shttp_info->peer_hostname = reqInfo->shttp_info->peer_hostname;
+       newInfo->shttp_info->peer_port = 0;
+       newInfo->shttp_info->server = 1;
+ 
+       RequestMain(newInfo);
+       close(newInfo->in);
+ 
+       if (!strcmp(newInfo->outh_content_type,SHTTP_MAGIC_TYPE)) {
+     	FILE *f;
+ 
+ 	/* at this point we know file exists and is readable */	
+ 
+     	if(!(f = FOpen(newInfo->filename,"r"))) {
+            log_reason(newInfo,"ADC screwed up somehow ZZZZ",
+                    				newInfo->filename);
+            die(newInfo,SC_FORBIDDEN,newInfo->url);
+  	}
+ 
+ 	send_fp(reqInfo,f,NULL);	/* writes it out reqInfo->out */	
+ 	log_transaction(newInfo);
+ 	FClose(f);
+ 	return;
+       }
+ 
+       rflush(newInfo);
+       lseek(fileno(newInfo->out),SEEK_SET,0);
+ 
+       /* We are a server, not a client */
+       newInfo->shttp_info->server = 1;
+ 
+       TSW_set_me_system_opts(&shttp_ctx,newInfo->shttp_info->meOpts,OP_SERVER | OP_KEYPAIR);
+ 
+       shttp_set_masks(newInfo->privacy_enhancements,
+ 		      &shttp_sugg_process,&shttp_allow_process);
+       TSW_set_me_privacy_enhancements(newInfo->shttp_info->meOpts,
+ 				  shttp_sugg_process,shttp_allow_process);
+       set_shttp_authenticator(newInfo->shttp_info,
+ 			      shttp_sugg_process,shttp_allow_process);
+ 
+    /* make sure peer hostname is in newInfo->shttp_info ??? */
+ 
+       newInfo->shttp_info->process = 0;
+ 
+       if (result = TSW_io_shttp_wrap(&shttp_ctx,fileno(newInfo->out),
+ 		    fileno(reqInfo->out),newInfo->shttp_info,tsw_null_func))
+ 	die(reqInfo,SC_BAD_REQUEST,TSW_shttp_explain_error(result));
+ 
+       return;
+     }
+ #endif /* SHTTP */
+ 
+ #ifdef LOG_TIMES
+     if (reqInfo->hostInfo->log_opts & LOG_REALTIME)
+       gettimeofday(&(reqInfo->time_process), NULL);
+ #endif /* LOG_TIMES */
+ 
+     process_request(reqInfo);
  }
  
diff -brc ./http_request.h /X11/blong/httpd/src//http_request.h
*** ./http_request.h	Tue Jun 25 17:06:17 1996
--- /X11/blong/httpd/src//http_request.h	Fri Apr  5 12:55:04 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_request.h,v 1.20 1996/04/05 18:55:04 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_request.h,v 1.20 1996/04/05 18:55:04 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: http_request.o
diff -brc ./http_send.c /X11/blong/httpd/src//http_send.c
*** ./http_send.c	Tue Jun 25 17:06:17 1996
--- /X11/blong/httpd/src//http_send.c	Tue Jun 25 16:59:26 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   * 
!  * http_send.c,v 1.34 1996/04/05 18:55:06 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   * 
!  * $Id: http_send.c,v 1.38 1996/06/12 20:35:36 acain Exp $
   *
   ************************************************************************
   *
***************
*** 42,47 ****
--- 42,51 ----
  #include <setjmp.h>
  #include <ctype.h>
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "fdwrap.h"
  #include "allocate.h"
  #include "http_send.h"
***************
*** 61,68 ****
  #ifdef FCGI_SUPPORT
  # include "fcgi.h"
  #endif /* FCGI_SUPPORT */
  
! static void (*exit_callback)(void);
  
  void send_node(per_request *reqInfo) 
  {
--- 65,75 ----
  #ifdef FCGI_SUPPORT
  # include "fcgi.h"
  #endif /* FCGI_SUPPORT */
+ #ifdef SSL_SUPPORT 
+ # include "http_ssl.h"
+ #endif /* SSL_SUPPORT */
  
! void (*exit_callback)(void);
  
  void send_node(per_request *reqInfo) 
  {
***************
*** 191,196 ****
--- 198,210 ----
        }
      }
      reqInfo->bytes_sent = 0;
+ 						/* wacky hack by ADC ZZZ */
+ #ifdef SHTTP
+     if (!strcmp(reqInfo->outh_content_type,SHTTP_MAGIC_TYPE)) {
+       FClose(f);
+       return;
+     }
+ #endif /* SHTTP */
  
  #ifdef BLACKOUT_CODE
      if (!strcmp(reqInfo->outh_content_type,BLACKOUT_MAGIC_TYPE)) {
***************
*** 328,333 ****
--- 342,348 ----
    {
      register int x,max;
      char *str;
+     int l,u;
  
      str = newString(HUGE_STRING_LEN,STR_TMP);
  
***************
*** 334,341 ****
      max=count_dirs(reqInfo->filename);
      for(x=max ; x > 0 ; x--) {
          make_dirstr(reqInfo->filename,x+1,str);
!         if(!(stat(str,finfo))) {
! 	  int l=strlen(str);
  	  strcat(reqInfo->path_info,&(reqInfo->filename[l]));
  	  reqInfo->filename[l] = '\0';
  	  reqInfo->url[strlen(reqInfo->url) - strlen(reqInfo->path_info)]='\0';
--- 349,358 ----
      max=count_dirs(reqInfo->filename);
      for(x=max ; x > 0 ; x--) {
          make_dirstr(reqInfo->filename,x+1,str);
! 	l=strlen(str);
! 	u=strlen(reqInfo->url);
!         if(!(stat(str,finfo)) && 
! 	   !strcmp(reqInfo->filename+l, reqInfo->url+u-strlen(reqInfo->filename+l))) {
  	  strcat(reqInfo->path_info,&(reqInfo->filename[l]));
  	  reqInfo->filename[l] = '\0';
  	  reqInfo->url[strlen(reqInfo->url) - strlen(reqInfo->path_info)]='\0';
***************
*** 385,394 ****
--- 402,418 ----
  	    reqInfo->status = SC_AUTH_REQUIRED;
  	set_stat_line(reqInfo);
      }    
+ #ifdef LOG_TIMES
+     if (reqInfo->hostInfo->log_opts & LOG_REALTIME)
+       gettimeofday(&(reqInfo->time_send), NULL);
+ #endif /* LOG_TIMES */
      rprintf(reqInfo,"%s %s%c%c",protocals[reqInfo->http_version],
  	    reqInfo->status_line,CR,LF);
      rprintf(reqInfo,"Date: %s%c%c",gm_timestr_822(time(NULL)),CR,LF);
      rprintf(reqInfo,"Server: %s%c%c",SERVER_VERSION,CR,LF);
+ #ifdef SHTTP
+     rprintf(reqInfo,"Security-Scheme: %s/%s%c%c",SHTTP_TITLE,SHTTP_VERSION,CR,LF);
+ #endif /* SHTTP */
      if (reqInfo->hostInfo->annotation_server[0])
  	rprintf(reqInfo,"Annotations-cgi: %s%c%c",
  		reqInfo->hostInfo->annotation_server,CR,LF);
***************
*** 439,445 ****
--- 463,485 ----
      }
      if(reqInfo->outh_cgi)
          rprintf(reqInfo,"%s",reqInfo->outh_cgi);
+ #ifdef SHTTP
+     if (reqInfo->RequestFlags & DOING_SHTTP) {
+       char *tmp;
  
+       if (tmp = TSW_create_internal_headers(&shttp_ctx,reqInfo->shttp_info)) {
+ 	rprintf(reqInfo,"%s",tmp);
+ 
+ #ifdef SHTTP_DEBUG
+       fprintf(stderr,"shttp internal headers:\n----------------\n%s",tmp);
+       fflush(stderr);
+ #endif /* SHTTP_DEBUG */
+ 
+ 	Free(tmp);
+       }
+     }
+ #endif /* SHTTP */ 
+ 
      rprintf(reqInfo,"%c%c",CR,LF);
  
  /* CLF doesn't include the headers, I don't think, so clear the information
***************
*** 520,525 ****
--- 560,566 ----
          alarm(timeout);
          if((n=fread(buf,sizeof(char),IOBUFSIZE,f)) < 1) {
  	   if (errno != EINTR) break;
+ 	    else errno = 0;
          }
  
          o=0;
***************
*** 531,539 ****
--- 572,586 ----
   *   For now, we'll just replace, but may have to #define one or the other
   *   depending on the system.
   */
+ #ifdef SSL_SUPPORT
+ 	    if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+ 	      w = SSL_write(ssl_con,&buf[o],n);
+             } else
+ #endif /* SSL_SUPPORT */
                w = write(fileno(reqInfo->out),&buf[o],n);
  	    if (w < 0) {
  	      if (errno != EINTR) break;
+ 		else errno = 0;
  	    }
  				/* there goes ADC again...  ZZZZ */
  /*
***************
*** 566,574 ****
  #else
     va_start(argList);
  #endif /* HAVE_VARARGS */
     x = vfprintf(reqInfo->out, format, argList);
  
- 
     va_end(argList);
  
     reqInfo->bytes_sent += x;
--- 613,628 ----
  #else
     va_start(argList);
  #endif /* HAVE_VARARGS */
+ #ifdef SSL_SUPPORT
+    if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+      char tmp[HUGE_STRING_LEN];
+      vsprintf(tmp, format, argList);
+      x = strlen(tmp);
+      SSL_write(ssl_con,tmp,x);
+    } else
+ #endif /* SSL_SUPPORT */
     x = vfprintf(reqInfo->out, format, argList);
  
     va_end(argList);
  
     reqInfo->bytes_sent += x;
***************
*** 581,596 ****
--- 635,682 ----
  int rputs(char *string, per_request *reqInfo)
  {
    reqInfo->bytes_sent += strlen(string);
+ #ifdef SSL_SUPPORT
+   if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+     return SSL_write(ssl_con,string,strlen(string));
+   } else
+ #endif /* SSL_SUPPORT */
    return fputs(string,reqInfo->out);
  }
  
+ /* rputsn() print n characters from string (doesn't check for end of string)
+  */
+ 
+ int rputsn(per_request *reqInfo, char *string, int len)
+ {
+   reqInfo->bytes_sent += len;
+ #ifdef SSL_SUPPORT
+   if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+     return SSL_write(ssl_con,string,len);
+   } else
+ #endif /* SSL_SUPPORT */
+   return fwrite(string,sizeof(char),len,reqInfo->out);
+ }
+ 
  int rputc(int ch, per_request *reqInfo)
  { 
    (reqInfo->bytes_sent)++;
+ #ifdef SSL_SUPPORT
+   if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+     char tmp[2];
+     tmp[0] = ch;
+     tmp[1] = '\0';
+     return SSL_write(ssl_con,tmp,1);
+   } else
+ #endif /* SSL_SUPPORT */
    return putc(ch, reqInfo->out);
  }
  
  int rflush(per_request *reqInfo)
  {
+ #ifdef SSL_SUPPORT
+   if (ssl_enabled && (reqInfo->RequestFlags & DOING_SSL)) {
+     return 0;
+   } else
+ #endif /* SSL_SUPPORT */
    return fflush(reqInfo->out);
  }
diff -brc ./http_send.h /X11/blong/httpd/src//http_send.h
*** ./http_send.h	Tue Jun 25 17:06:18 1996
--- /X11/blong/httpd/src//http_send.h	Tue Jun 25 16:59:47 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * http_send.h,v 1.10 1996/03/27 20:44:12 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: http_send.h,v 1.11 1996/06/06 02:44:52 blong Exp $
   *
   ************************************************************************
   *
***************
*** 20,25 ****
--- 20,27 ----
  #ifndef _HTTP_SEND_H_
  #define _HTTP_SEND_H_
  
+ extern void (*exit_callback)(void);
+ 
  /* function prototypes */
  void send_node(per_request *reqInfo);
  void send_file(per_request *reqInfo, struct stat *fi, char allow_options);
***************
*** 31,36 ****
--- 33,39 ----
  
  int rprintf(per_request *reqInfo, char *format, ...);
  int rputs(char *string, per_request *reqInfo);
+ int rputsn(per_request *reqInfo, char *string, int len);
  int rputc(int ch, per_request *reqInfo);
  int rflush(per_request *reqInfo);
  
Only in /X11/blong/httpd/src/: http_send.o
Only in /X11/blong/httpd/src/: http_shttp.c
Only in /X11/blong/httpd/src/: http_shttp.h
Only in /X11/blong/httpd/src/: http_ssl.c
Only in /X11/blong/httpd/src/: http_ssl.h
diff -brc ./httpd.c /X11/blong/httpd/src//httpd.c
*** ./httpd.c	Tue Jun 25 17:06:18 1996
--- /X11/blong/httpd/src//httpd.c	Wed Jun 12 16:11:56 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * httpd.c,v 1.131 1996/04/05 18:55:09 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: httpd.c,v 1.137 1996/06/12 20:35:39 acain Exp $
   *
   ************************************************************************
   *
***************
*** 66,71 ****
--- 66,75 ----
  # include <sys/resource.h>
  #endif /* NO_SYS_RESOURCE_H */
  #include "constants.h"
+ #ifdef SHTTP
+ # include <shttp.h>
+ # include "http_shttp.h"
+ #endif /* SHTTP */
  #include "fdwrap.h"
  #include "allocate.h"
  #include "httpd.h"
***************
*** 80,85 ****
--- 84,95 ----
  #include "http_mime.h"
  #include "http_send.h"
  #include "util.h"
+ #if defined(KRB4) || defined(KRB5)
+ # include "http_kerberos.h"
+ #endif /* KRB4 || KRB5 */
+ #ifdef SSL_SUPPORT
+ # include "http_ssl.h"
+ #endif /* SSL_SUPPORT */
  
  JMP_BUF restart_buffer;
  int mainSocket;
***************
*** 109,115 ****
  #define HAVE_KERBEROS
  #endif /* defined(KRB4) || defined(KRB5) */
  
- 
  void htexit(per_request *reqInfo, int status, int die_type) 
  {
  #ifdef NO_SIGLONGJMP
--- 119,124 ----
***************
*** 426,431 ****
--- 435,443 ----
  		 CLIENT_SOCK_ADDR *sa_client)
  {
  static per_request *reqInfo = NULL;
+ #ifdef SHTTP
+    static int sk_size;
+ #endif /* SHTTP */
  
  #ifndef THREADED
      close(mainSocket);
***************
*** 443,448 ****
--- 455,464 ----
      standalone = 0;
      keep_alive.nCurrRequests = 0;
  
+ #ifdef SHTTP
+     TSW_make_session_key(&shttp_ctx,HA_DES_ECB,0,&sk_size);
+ #endif /* SHTTP */
+ 
      /* Only try to switch if we're running as root */
      if(!geteuid()) {
      if (setuid(user_id) == -1) {
***************
*** 559,565 ****
  	if (parent_pipe != Children[x].childfd) close(Children[x].childfd);
      }
      
!     free(Children);
  #endif /* THREADED */
  
  #ifdef NO_SIGLONGJMP
--- 575,581 ----
  	if (parent_pipe != Children[x].childfd) close(Children[x].childfd);
      }
      
!     Free(Children);
  #endif /* THREADED */
  
  #ifdef NO_SIGLONGJMP
***************
*** 687,692 ****
--- 703,711 ----
  #ifdef SETPROCTITLE
      char namestr[30];
  #endif /* SETPROCTITLE */
+ #ifdef SHTTP
+     int sk_size;
+ #endif /* SHTTP */
  
      pid = 1;
  #ifndef NEED_SPIPE
***************
*** 711,716 ****
--- 730,741 ----
      
  	if (!pid) {
  	 /* Child */
+ #ifdef SHTTP
+          /* Strobe the session key generator so that different children
+ 	  * have different key sequences.
+ 	  */
+ 	    TSW_make_session_key(&shttp_ctx,HA_DES_ECB,0,&sk_size);
+ #endif /* SHTTP */
              
  	    close(Children[childnum].childfd); 
  #ifdef BSD
***************
*** 765,771 ****
      exit(1); 
    }
    
!   bzero((char *) sa_server, sizeof(*sa_server));
    sa_server->sin_family=AF_INET;
    sa_server->sin_addr= gConfiguration->address_info; 
    /*    sa_server.sin_addr.s_addr=htonl(INADDR_ANY); */
--- 790,796 ----
      exit(1); 
    }
    
!   memset(sa_server, 0, sizeof(*sa_server));
    sa_server->sin_family=AF_INET;
    sa_server->sin_addr= gConfiguration->address_info; 
    /*    sa_server.sin_addr.s_addr=htonl(INADDR_ANY); */
***************
*** 1025,1031 ****
  	  close(Children[x].childfd);
  	  kill(Children[x].pid,SIGKILL);
          }
!         free(Children);
  #endif /* NO_PASS */        
          free_host_conf();
  	freeAllStrings(STR_HUP);
--- 1050,1056 ----
  	  close(Children[x].childfd);
  	  kill(Children[x].pid,SIGKILL);
          }
!         Free(Children);
  #endif /* NO_PASS */        
          free_host_conf();
  	freeAllStrings(STR_HUP);
***************
*** 1039,1044 ****
--- 1064,1070 ----
      } /* while (!Exit) */
  } /* standalone_main */
  
+ 
  void default_banner(FILE* fout)
  {
    fprintf(fout,"NCSA HTTPd %s\n",SERVER_SOURCE);
***************
*** 1045,1053 ****
    fprintf(fout,"Licensed material.  Portions of this work are\n");
    fprintf(fout,"Copyright (C) 1995-1996 Board of Trustees of the University of Illinois\n");
    fprintf(fout,"Copyright (C) 1995-1996 The Apache Group\n");
! #if defined(DIGEST_AUTH)
    fprintf(fout,"Copyright (C) 1989-1993 RSA Data Security, Inc.\n");
! #endif /* DIGEST_AUTH */
  #ifdef DIGEST_AUTH
    fprintf(fout,"Copyright (C) 1993-1994 Carnegie Mellon University\n");
    fprintf(fout,"Copyright (C) 1991      Bell Communications Research, Inc. (Bellcore)\n");
--- 1071,1082 ----
    fprintf(fout,"Licensed material.  Portions of this work are\n");
    fprintf(fout,"Copyright (C) 1995-1996 Board of Trustees of the University of Illinois\n");
    fprintf(fout,"Copyright (C) 1995-1996 The Apache Group\n");
! #ifdef SHTTP
!   fprintf(fout,"Copyright (C) 1994-1995 Enterprise Integration Technologies Corp.\n");
! #endif /* SHTTP */
! #if defined(SHTTP) || defined(DIGEST_AUTH)
    fprintf(fout,"Copyright (C) 1989-1993 RSA Data Security, Inc.\n");
! #endif /* SHTTP || DIGEST_AUTH */
  #ifdef DIGEST_AUTH
    fprintf(fout,"Copyright (C) 1993-1994 Carnegie Mellon University\n");
    fprintf(fout,"Copyright (C) 1991      Bell Communications Research, Inc. (Bellcore)\n");
***************
*** 1056,1061 ****
--- 1085,1093 ----
  #ifdef FCGI_SUPPORT
    fprintf(fout,"Copyright (C) 1995      Open Market, Inc.\n");
  #endif /* FCGI_SUPPORT */
+ #ifdef SSL_SUPPORT
+   fprintf(fout,"Copyright (C) 1995      Tim Hudson, Eric Young\n");
+ #endif /* SSL_SUPPORT */
    fflush(fout);
  }
  
***************
*** 1071,1076 ****
--- 1103,1111 ----
    fprintf(stderr,"\tTACHOMETER\n");
  #endif /* TACHOMETER */
  #endif /* SETPROCTITLE */
+ #ifdef LOG_TIMES
+   fprintf(stderr,"\tLOG_TIMES\n");
+ #endif /* LOG_TIMES */
  #ifdef XBITHACK
    fprintf(stderr,"\tXBITHACK\n");
  #endif /* XBITHACK */
***************
*** 1080,1088 ****
--- 1115,1129 ----
  #ifdef NO_PASS
    fprintf(stderr,"\tNO_PASS\n");
  #endif /* NO_PASS */
+ #ifdef FCGI_SUPPORT
+   fprintf(stderr,"\tFCGI_SUPPORT\n");
+ #endif /* FCGI_SUPPORT */ 
  #ifdef DBM_SUPPORT
    fprintf(stderr,"\tDBM_SUPPORT\n");
  #endif /* DBM_SUPPORT */
+ #ifdef NIS_SUPPORT
+   fprintf(stderr,"\tNIS_SUPPORT\n");
+ #endif /* NIS_SUPPORT */
  #ifdef DIGEST_AUTH
    fprintf(stderr,"\tDIGEST_AUTH\n");
  #endif /* DIGEST_AUTH */
***************
*** 1095,1103 ****
  #ifdef KRB5
    fprintf(stderr,"\tKRB5\n");
  #endif /* KRB5 */
! #ifdef PEM_AUTH
!   fprintf(stderr,"\tPEM_AUTH\n");
! #endif /* PEM_AUTH */
    fprintf(stderr,"\tHTTPD_ROOT = %s\n",HTTPD_ROOT);
    fprintf(stderr,"\tDOCUMENT_ROOT = %s\n", DOCUMENT_LOCATION);
  
--- 1136,1147 ----
  #ifdef KRB5
    fprintf(stderr,"\tKRB5\n");
  #endif /* KRB5 */
! #ifdef SSL_SUPPORT
!   fprintf(stderr,"\tSSL_SUPPORT:%s\n",SSL_VERSION);
! #endif /* SSL_SUPPORT */
! #ifdef SHTTP
!   fprintf(stderr,"\tSHTTP:%s/%s\n",SHTTP_TITLE,SHTTP_VERSION);
! #endif /* SHTTP */
    fprintf(stderr,"\tHTTPD_ROOT = %s\n",HTTPD_ROOT);
    fprintf(stderr,"\tDOCUMENT_ROOT = %s\n", DOCUMENT_LOCATION);
  
***************
*** 1178,1184 ****
              } else {
  	      char *cwd = getcwd(NULL,255);
  	      make_full_path(cwd, optarg, server_confname);
! 	      if (cwd) free(cwd);
  	    }  
              break;
            case 'v':
--- 1222,1228 ----
              } else {
  	      char *cwd = getcwd(NULL,255);
  	      make_full_path(cwd, optarg, server_confname);
! 	      if (cwd) Free(cwd);
  	    }  
              break;
            case 'v':
***************
*** 1202,1207 ****
--- 1246,1257 ----
  	    break;
  #endif /* KRB5 */
  #endif  /* HAVE_KERBEROS */
+ #ifdef SSL_SUPPORT
+ 	  case 's':
+ 	    ssl_enabled = TRUE;
+ 	    break;
+ #endif /* SSL_SUPPORT */
+ 
            case '?':
              usage(argv[0]);
          }
***************
*** 1223,1236 ****
--- 1273,1308 ----
      initproctitle(process_name, argc, argv, envp); 
  #endif /* SETPROCTITLE */
  
+ #ifdef SSL_SUPPORT
+     if (ssl_enabled == TRUE)
+       ssl_init();
+ #endif /* SSL_SUPPORT */
      set_group_privs();
      get_local_host();
  
+ #ifdef SHTTP
+     if(shttp_server_dns){
+       int r;
+       
+       if(r=shttp_console_login("garbage",shttp_server_dns,tsw_null_func)) {
+          fprintf(stderr,"%s: aborted\n",TSW_shttp_explain_error(r));
+          exit(1);
+       } else
+ 	 fprintf(stderr,"password good.\n");
+ 
+       TSW_set_server_kludge(&shttp_ctx);
+     }
+ #endif /* SHTTP */ 
+     
  #ifdef __QNX__
      dup2(0,1);
      dup2(0,2);
  #endif /* __QNX */
     
+ #ifdef LOG_TIMES
+     clk_ticks = sysconf(_SC_CLK_TCK);
+ #endif /* LOG_TIMES */
+ 
      if(standalone)
          standalone_main(argc,argv);
      else {
***************
*** 1250,1255 ****
--- 1322,1331 ----
          RequestMain(reqInfo);
  	rflush(reqInfo);
      }
+ 
+ #ifdef SHTTP
+     TSW_crypt_term(&shttp_ctx);
+ #endif
  
      close_all_logs();
      fclose(stdin);
diff -brc ./httpd.h /X11/blong/httpd/src//httpd.h
*** ./httpd.h	Tue Jun 25 17:06:18 1996
--- /X11/blong/httpd/src//httpd.h	Wed Mar 27 14:44:19 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * httpd.h,v 1.97 1996/03/27 20:44:19 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: httpd.h,v 1.97 1996/03/27 20:44:19 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: httpd.o
diff -brc ./imagemap.c /X11/blong/httpd/src//imagemap.c
*** ./imagemap.c	Tue Jun 25 17:06:18 1996
--- /X11/blong/httpd/src//imagemap.c	Wed Jun  5 21:44:56 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * imagemap.c,v 1.15 1996/04/05 19:14:19 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: imagemap.c,v 1.19 1996/06/06 02:44:56 blong Exp $
   *
   ************************************************************************
   *
***************
*** 37,42 ****
--- 37,43 ----
  #include "http_request.h"
  #include "imagemap.h"
  #include "cgi.h"
+ #include "util.h"
  
  #ifdef IMAGEMAP_SUPPORT 
  
***************
*** 257,265 ****
  
  void sendmesg(per_request* reqInfo, char *url, FILE *fp)
  {
!     char *loc;
  
      loc = newString(HUGE_STRING_LEN,STR_REQ);
  
      FClose(fp);
      if (!strchr(url, ':')) {   /*** If not a full URL ***/
--- 258,267 ----
  
  void sendmesg(per_request* reqInfo, char *url, FILE *fp)
  {
!     char *loc, *furl;
  
      loc = newString(HUGE_STRING_LEN,STR_REQ);
+     furl = newString(HUGE_STRING_LEN,STR_REQ);
  
      FClose(fp);
      if (!strchr(url, ':')) {   /*** If not a full URL ***/
***************
*** 267,281 ****
          char *last = strrchr(reqInfo->url,'/');
          int x = 0, y = 0;
          while (((reqInfo->url+x) <= last) && (y < HUGE_STRING_LEN)) {
!           loc = *(reqInfo->url+x);
            x++; y++;
          }
          loc[y] = '\0';
!         die(reqInfo,SC_REDIRECT_TEMP,loc);
        } else {
          strncpy(loc,url,HUGE_STRING_LEN);
-         die(reqInfo,SC_REDIRECT_TEMP,loc);
        }
      } else {
        die(reqInfo,SC_REDIRECT_TEMP,url);
      }
--- 269,284 ----
          char *last = strrchr(reqInfo->url,'/');
          int x = 0, y = 0;
          while (((reqInfo->url+x) <= last) && (y < HUGE_STRING_LEN)) {
!           loc[y] = *(reqInfo->url+x);
            x++; y++;
          }
          loc[y] = '\0';
! 	strncat(loc,url,HUGE_STRING_LEN - y);
        } else {
          strncpy(loc,url,HUGE_STRING_LEN);
        }
+       construct_url(furl, reqInfo->hostInfo, loc);
+       die(reqInfo,SC_REDIRECT_TEMP,furl);
      } else {
        die(reqInfo,SC_REDIRECT_TEMP,url);
      }
diff -brc ./imagemap.h /X11/blong/httpd/src//imagemap.h
*** ./imagemap.h	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//imagemap.h	Fri Apr  5 12:55:18 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * imagemap.h,v 1.6 1996/04/05 18:55:18 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: imagemap.h,v 1.6 1996/04/05 18:55:18 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: imagemap.o
diff -brc ./md5.c /X11/blong/httpd/src//md5.c
*** ./md5.c	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//md5.c	Wed Jun 12 16:11:57 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * md5.c,v 1.6 1996/03/06 23:21:21 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: md5.c,v 1.7 1996/06/12 20:35:41 acain Exp $
   *
   ************************************************************************
   *
***************
*** 38,46 ****
  
  #include <stdio.h>
  #include <string.h>
- #ifndef SHTTP
- #include "global.h" 
- #endif /* SHTTP */
  #include "md5.h"
  
  void md5 (unsigned char *string, char result[33])
--- 38,43 ----
diff -brc ./md5.h /X11/blong/httpd/src//md5.h
*** ./md5.h	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//md5.h	Wed Jun 12 16:27:03 1996
***************
*** 28,35 ****
  
  /* MD5 context. */
  typedef struct {
!   UINT4 state[4];                                   /* state (ABCD) */
!   UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
    unsigned char buffer[64];                         /* input buffer */
  } MD5_CTX;
  
--- 28,35 ----
  
  /* MD5 context. */
  typedef struct {
!   H_UINT4 state[4];                                   /* state (ABCD) */
!   H_UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
    unsigned char buffer[64];                         /* input buffer */
  } MD5_CTX;
  
Only in /X11/blong/httpd/src/: md5.o
diff -brc ./md5c.c /X11/blong/httpd/src//md5c.c
*** ./md5c.c	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//md5c.c	Wed Jun 12 16:28:43 1996
***************
*** 27,33 ****
  #include "config.h"
  #include "portability.h"
  
- #include "global.h"
  #include "md5.h"
  
  /* Constants for MD5Transform routine.
--- 27,32 ----
***************
*** 49,61 ****
  #define S43 15
  #define S44 21
  
! static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
! static void Encode PROTO_LIST
!   ((unsigned char *, UINT4 *, unsigned int));
! static void Decode PROTO_LIST
!   ((UINT4 *, unsigned char *, unsigned int));
! static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
! static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));
  
  static unsigned char PADDING[64] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
--- 48,58 ----
  #define S43 15
  #define S44 21
  
! static void MD5Transform(H_UINT4 [4], unsigned char [64]);
! static void Encode(unsigned char *, H_UINT4 *, unsigned int);
! static void Decode(H_UINT4 *, unsigned char *, unsigned int);
! static void MD5_memcpy(H_POINTER, H_POINTER, unsigned int);
! static void MD5_memset(H_POINTER, int, unsigned int);
  
  static unsigned char PADDING[64] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
***************
*** 78,99 ****
  Rotation is separate from addition to prevent recomputation.
   */
  #define FF(a, b, c, d, x, s, ac) { \
!  (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
  #define GG(a, b, c, d, x, s, ac) { \
!  (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
  #define HH(a, b, c, d, x, s, ac) { \
!  (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
  #define II(a, b, c, d, x, s, ac) { \
!  (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
--- 75,96 ----
  Rotation is separate from addition to prevent recomputation.
   */
  #define FF(a, b, c, d, x, s, ac) { \
!  (a) += F ((b), (c), (d)) + (x) + (H_UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
  #define GG(a, b, c, d, x, s, ac) { \
!  (a) += G ((b), (c), (d)) + (x) + (H_UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
  #define HH(a, b, c, d, x, s, ac) { \
!  (a) += H ((b), (c), (d)) + (x) + (H_UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
  #define II(a, b, c, d, x, s, ac) { \
!  (a) += I ((b), (c), (d)) + (x) + (H_UINT4)(ac); \
   (a) = ROTATE_LEFT ((a), (s)); \
   (a) += (b); \
    }
***************
*** 127,136 ****
  	index = (unsigned int)((context->count[0] >> 3) & 0x3F);
  
  	/* Update number of bits */
! 	if ((context->count[0] += ((UINT4)inputLen << 3))
! 		< ((UINT4)inputLen << 3))
  		context->count[1]++;
! 	context->count[1] += ((UINT4)inputLen >> 29);
  
  	partLen = 64 - index;
  
--- 124,133 ----
  	index = (unsigned int)((context->count[0] >> 3) & 0x3F);
  
  	/* Update number of bits */
! 	if ((context->count[0] += ((H_UINT4)inputLen << 3))
! 		< ((H_UINT4)inputLen << 3))
  		context->count[1]++;
! 	context->count[1] += ((H_UINT4)inputLen >> 29);
  
  	partLen = 64 - index;
  
***************
*** 138,144 ****
  	 */
  	if (inputLen >= partLen) {
  		MD5_memcpy
! 			((POINTER)&context->buffer[index], (POINTER)input, partLen);
  		MD5Transform (context->state, context->buffer);
  		
  		for (i = partLen; i + 63 < inputLen; i += 64)
--- 135,141 ----
  	 */
  	if (inputLen >= partLen) {
  		MD5_memcpy
! 			((H_POINTER)&context->buffer[index], (H_POINTER)input, partLen);
  		MD5Transform (context->state, context->buffer);
  		
  		for (i = partLen; i + 63 < inputLen; i += 64)
***************
*** 151,157 ****
  
  	/* Buffer remaining input */
  	MD5_memcpy
! 		((POINTER)&context->buffer[index], (POINTER)&input[i],
  		 inputLen-i);
  }
  
--- 148,154 ----
  
  	/* Buffer remaining input */
  	MD5_memcpy
! 		((H_POINTER)&context->buffer[index], (H_POINTER)&input[i],
  		 inputLen-i);
  }
  
***************
*** 181,196 ****
  	
  	/* Zeroize sensitive information.
  	 */
! 	MD5_memset ((POINTER)context, 0, sizeof (*context));
  }
  
  /* MD5 basic transformation. Transforms state based on block.
   */
  static void MD5Transform (state, block)
! 	UINT4 state[4];
  	unsigned char block[64];
  {
! 	UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  	
  	Decode (x, block, 64);
  	
--- 178,193 ----
  	
  	/* Zeroize sensitive information.
  	 */
! 	MD5_memset ((H_POINTER)context, 0, sizeof (*context));
  }
  
  /* MD5 basic transformation. Transforms state based on block.
   */
  static void MD5Transform (state, block)
! 	H_UINT4 state[4];
  	unsigned char block[64];
  {
! 	H_UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  	
  	Decode (x, block, 64);
  	
***************
*** 273,287 ****
  	
  	/* Zeroize sensitive information.
  	 */
! 	MD5_memset ((POINTER)x, 0, sizeof (x));
  }
  
! /* Encodes input (UINT4) into output (unsigned char). Assumes len is
    a multiple of 4.
   */
  static void Encode (output, input, len)
  	unsigned char *output;
! 	UINT4 *input;
  	unsigned int len;
  {
  	unsigned int i, j;
--- 270,284 ----
  	
  	/* Zeroize sensitive information.
  	 */
! 	MD5_memset ((H_POINTER)x, 0, sizeof (x));
  }
  
! /* Encodes input (H_UINT4) into output (unsigned char). Assumes len is
    a multiple of 4.
   */
  static void Encode (output, input, len)
  	unsigned char *output;
! 	H_UINT4 *input;
  	unsigned int len;
  {
  	unsigned int i, j;
***************
*** 294,304 ****
  	}
  }
  
! /* Decodes input (unsigned char) into output (UINT4). Assumes len is
    a multiple of 4.
   */
  static void Decode (output, input, len)
! 	UINT4 *output;
  	unsigned char *input;
  	unsigned int len;
  {
--- 291,301 ----
  	}
  }
  
! /* Decodes input (unsigned char) into output (H_UINT4). Assumes len is
    a multiple of 4.
   */
  static void Decode (output, input, len)
! 	H_UINT4 *output;
  	unsigned char *input;
  	unsigned int len;
  {
***************
*** 305,312 ****
  	unsigned int i, j;
  	
  	for (i = 0, j = 0; j < len; i++, j += 4)
! 		output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
! 			(((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
  }
  
  /* Note: Replace "for loop" with standard memcpy if possible.
--- 302,309 ----
  	unsigned int i, j;
  	
  	for (i = 0, j = 0; j < len; i++, j += 4)
! 		output[i] = ((H_UINT4)input[j]) | (((H_UINT4)input[j+1]) << 8) |
! 			(((H_UINT4)input[j+2]) << 16) | (((H_UINT4)input[j+3]) << 24);
  }
  
  /* Note: Replace "for loop" with standard memcpy if possible.
***************
*** 313,320 ****
   */
  
  static void MD5_memcpy (output, input, len)
! 	POINTER output;
! 	POINTER input;
  	unsigned int len;
  {
  	unsigned int i;
--- 310,317 ----
   */
  
  static void MD5_memcpy (output, input, len)
! 	H_POINTER output;
! 	H_POINTER input;
  	unsigned int len;
  {
  	unsigned int i;
***************
*** 326,332 ****
  /* Note: Replace "for loop" with standard memset if possible.
   */
  static void MD5_memset (output, value, len)
! 	POINTER output;
  	int value;
  	unsigned int len;
  {
--- 323,329 ----
  /* Note: Replace "for loop" with standard memset if possible.
   */
  static void MD5_memset (output, value, len)
! 	H_POINTER output;
  	int value;
  	unsigned int len;
  {
Only in /X11/blong/httpd/src/: md5c.o
diff -brc ./open_logfile.c /X11/blong/httpd/src//open_logfile.c
*** ./open_logfile.c	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//open_logfile.c	Tue Nov 28 03:02:17 1995
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * open_logfile.c,v 1.6 1995/11/28 09:02:17 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: open_logfile.c,v 1.6 1995/11/28 09:02:17 blong Exp $
   *
   ************************************************************************
   *
diff -brc ./open_logfile.h /X11/blong/httpd/src//open_logfile.h
*** ./open_logfile.h	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//open_logfile.h	Mon Oct 23 13:07:14 1995
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * open_logfile.h,v 1.2 1995/09/20 23:37:11 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: open_logfile.h,v 1.2 1995/09/20 23:37:11 blong Exp $
   *
   ************************************************************************
   *
Only in /X11/blong/httpd/src/: open_logfile.o
Only in .: patch
diff -brc ./portability.h /X11/blong/httpd/src//portability.h
*** ./portability.h	Tue Jun 25 17:06:19 1996
--- /X11/blong/httpd/src//portability.h	Wed Jun 12 17:51:32 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * portability.h,v 1.32 1996/03/27 20:44:29 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: portability.h,v 1.35 1996/06/12 22:51:32 blong Exp $
   *
   ************************************************************************
   *
***************
*** 70,75 ****
--- 70,76 ----
  #define DIR_FILENO(p)  ((p)->dd_fd)
  #define HEAD_CRYPT
  #define MISSING_HEADERS
+ #define _H_M_WAIT
  
  #elif defined(AIX4)
  #undef BSD
***************
*** 204,217 ****
  
  
  #elif defined(LINUX)
! /* This release contains a Linux file descriptor hack using the /proc filesystem.
!    This is a largely unsupported feature, and will hopefully be replaced by one
!    of the other file descriptor passing mechanisms when they are supported by
!    the Linux kernel */
! /* #define NO_PASS */
! #define FD_LINUX
  /* Needed for newer versions of libc (5.2.x) to use FD_LINUX hack */
  #define DIRENT_ILLEGAL_ACCESS
  #undef BSD
  #undef NO_KILLPG
  #undef NO_SETSID
--- 205,217 ----
  
  
  #elif defined(LINUX)
! #define FD_BSD
! #define FD_BSDRENO
  /* Needed for newer versions of libc (5.2.x) to use FD_LINUX hack */
  #define DIRENT_ILLEGAL_ACCESS
+ #define DIR_FILENO(p)  ((p)->dd_fd)
+ #define CMSG_DATA(cmptr)  ((cmptr)->cmsg_data)
+ #define NEED_SYS_UN_H
  #undef BSD
  #undef NO_KILLPG
  #undef NO_SETSID
***************
*** 426,431 ****
--- 426,442 ----
  #ifndef MAXPATHLEN
  # include <sys/param.h>
  #endif /* MAX_PATHLEN */
+ 
+ 
+ /* RSA Portability Defns (from global.h), modified so as not to interfere */
+ /* POINTER defines a generic pointer type */
+ typedef unsigned char *H_POINTER;
+ 
+ /* UINT2 defines a two byte word */
+ typedef unsigned short int H_UINT2;
+ 
+ /* UINT4 defines a four byte word */
+ typedef unsigned long int H_UINT4;
  
  /* Some systems prefer sockaddr_in for some functions, and sock_addr
     for others 
Only in /X11/blong/httpd/src/: rfc1413.c
Only in /X11/blong/httpd/src/: rfc1413.h
Only in .: rfc822.c
Only in /X11/blong/httpd/src/: rfc931.o
diff -brc ./util.c /X11/blong/httpd/src//util.c
*** ./util.c	Tue Jun 25 17:06:20 1996
--- /X11/blong/httpd/src//util.c	Wed May 15 16:10:10 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * util.c,v 1.115 1996/03/27 20:44:30 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: util.c,v 1.116 1996/05/15 21:10:10 blong Exp $
   *
   ************************************************************************
   *
***************
*** 62,67 ****
--- 62,70 ----
  #include "host_config.h"
  #include "http_log.h"
  #include "httpd.h"
+ #ifdef SSL_SUPPORT
+ # include "http_ssl.h"
+ #endif /* SSL_SUPPORT */
  
  
  #undef DONTCOMPILEIN
***************
*** 615,620 ****
--- 618,632 ----
  	    signal(SIGALRM,getline_timed_out);
  	    alarm(timeout);
  
+ #ifdef SSL_SUPPORT
+ /* I don't think this will work with S-HTTP also, since we it
+  * would have to be able to use the SSL read command.  We really
+  * need a full file I/O interface of our own.
+  */
+ 	    if (options & G_SSL_READ) 
+ 	      ret = SSL_read(ssl_con, sb->buffer, size);
+              else
+ #endif /* SSL_SUPPORT */
  	    ret=read(sb->sd, sb->buffer, size);
  
  	    if (ret <= 0) {
***************
*** 645,652 ****
  	}
  	
  	c = sb->buffer[(sb->buf_posn)++];
!         if ((c == '\r') && (sb->buffer[sb->buf_posn] == '\n') && 
!             (sb->buf_posn + 1 < sb->buf_good) && 
              ((sb->buffer[sb->buf_posn + 1] == ' ') || 
  	     (sb->buffer[sb->buf_posn + 1] == '\t'))) 
          {
--- 657,664 ----
  	}
  	
  	c = sb->buffer[(sb->buf_posn)++];
!         if ((c == '\r') && (sb->buf_posn + 1 < sb->buf_good) && 
! 	    (sb->buffer[sb->buf_posn] == '\n') && 
              ((sb->buffer[sb->buf_posn + 1] == ' ') || 
  	     (sb->buffer[sb->buf_posn + 1] == '\t'))) 
          {
***************
*** 1266,1271 ****
--- 1278,1291 ----
   */
  void construct_url(char *full_url, per_host *host, char *url) 
  {
+ #ifdef SSL_SUPPORT 
+    if (ssl_enabled) {
+      if (port == DEFAULT_SSL_PORT)
+        sprintf(full_url,"%s://%s%s", "https",host->server_hostname,url);
+       else 
+        sprintf(full_url,"%s://%s:%d%s", "https",host->server_hostname,port,url);
+    } else 
+ #endif /* SSL_SUPPORT */
    {
       if (port == DEFAULT_PORT)
         sprintf(full_url,"%s://%s%s", "http",host->server_hostname,url);
diff -brc ./util.h /X11/blong/httpd/src//util.h
*** ./util.h	Tue Jun 25 17:06:20 1996
--- /X11/blong/httpd/src//util.h	Wed Mar 27 14:44:32 1996
***************
*** 10,16 ****
   *
   ************************************************************************
   *
!  * util.h,v 1.18 1996/03/27 20:44:32 blong Exp
   *
   ************************************************************************
   *
--- 10,16 ----
   *
   ************************************************************************
   *
!  * $Id: util.h,v 1.18 1996/03/27 20:44:32 blong Exp $
   *
   ************************************************************************
   *
***************
*** 28,33 ****
--- 28,36 ----
  #define G_RESET_BUF	1
  #define G_FLUSH		2
  #define G_SINGLE_CHAR   4
+ #ifdef SSL_SUPPORT
+ # define G_SSL_READ	8
+ #endif /* SSL_SUPPORT */
  
  
  /* util function prototypes */
Only in /X11/blong/httpd/src/: util.o
